#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"
#include "PlanetGeneratorHelpers.usf"

int leafDepth;
int nodeIndex; // always 0 ignore each leaf has its own isoCombinedValues buffer, this is left over from before

Buffer<float> isoValues; // All tree isoValues at maxResolution
Buffer<float> isoDeltaValues; // All tree isoValues at maxResolution

RWBuffer<float> isoCombinedValues; // out leaf iso values (leaf sized ready for averages i.e (voxelsPerAxis + 1)^3 in size)

int voxelsPerAxis;
int highResVoxelsPerAxis;

float3 leafPosition;
float3 octreePosition;
float baseDepthScale;

float GetDensity(int3 coord)
{
    float3 p = (float3(coord) / voxelsPerAxis) * 2.0 - 1.0;
    float sphere = length(p) - 0.5;
    return sphere;
}

// 6, 6, 6: (0-5)
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void Deformation(int3 id : SV_DispatchThreadID)
{
    int isoPerAxis = voxelsPerAxis + 1;
    if (any(id >= (isoPerAxis)))
        return;
    
    int isoPerAxisMaxRes = highResVoxelsPerAxis + 1;

    float ratio = baseDepthScale / 2.0; // 100
    float3 minimumCornerVoxelBodyPos = octreePosition - float3(ratio, ratio, ratio);
    
    float scale = baseDepthScale / (1 << leafDepth);
    float centerDis = scale / 2;
    float3 leafMinWorld = leafPosition - float3(centerDis, centerDis, centerDis);
    
    float voxelWorldSize = baseDepthScale / (highResVoxelsPerAxis); // 200/isoPerAxiMaxRes
    float3 offsetWorld = leafMinWorld - minimumCornerVoxelBodyPos;
    float3 offsetVoxelsF = offsetWorld / voxelWorldSize;
    
    float stride = (highResVoxelsPerAxis / voxelsPerAxis); //4
    stride /= (1 << leafDepth); 
    
    int3 startIndex = (int3) offsetVoxelsF + (id * stride);

    float count = 0.0;
    float sum = 0.0;

    if (stride > 1)
    {
        stride /= 2;
        for (int dz = startIndex.z - stride; dz < (startIndex.z + stride); dz++)
        {
            for (int dy = startIndex.y - stride; dy < (startIndex.y + stride); dy++)
            {
                for (int dx = startIndex.x - stride; dx < (startIndex.x + stride); dx++)
                {
                    int3 readBufferIndex = int3(dx, dy, dz);

                    if (any(readBufferIndex < 0)) continue;
                    if (any(readBufferIndex >= isoPerAxisMaxRes)) continue;
                    
                    int flat = GetIsoIndex(readBufferIndex, isoPerAxisMaxRes);
                    sum += clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
                    count++;
                }
            }
        }
    }
    else
    {
        int flat = GetIsoIndex(startIndex, isoPerAxisMaxRes);
        sum += clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
        count = 1;
    }
    
    float density = sum / count;
    int writeIndex = GetIsoIndex(id, isoPerAxis);
    isoCombinedValues[writeIndex] = density;
}
                
