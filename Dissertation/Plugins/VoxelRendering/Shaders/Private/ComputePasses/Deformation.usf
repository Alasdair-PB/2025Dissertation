#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"

float3 leafPosition;
int leafDepth;
int nodeIndex; // always 0 ignore each leaf has its own isoCombinedValues buffer, this is left over from before

Buffer<float> isoValues; // All tree isoValues at maxResolution
RWBuffer<float> isoCombinedValues; // out leaf iso values (leaf sized ready for averages i.e (voxelsPerAxis + 1)^3 in size)

float baseDepthScale;
int voxelsPerAxis;
int highResVoxelsPerAxis;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void Deformation(int3 id : SV_DispatchThreadID)
{
    if (any(id >= voxelsPerAxis)) return;
   
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
        
    float scale = baseDepthScale / (pow(2, leafDepth));
    float centerDis = scale / 2;
    float isoScale = (scale / (voxelsPerAxis));
    float3 worldPos = leafPosition - float3(centerDis, centerDis, centerDis);
    

    for (int isoIdx = 0; isoIdx < 15; isoIdx++)
    {
        float sum = 0.0;
        int count = 0;
        
        for (int dz = 0; dz < ratio; dz++)
        {
            for (int dy = 0; dy < ratio; dy++)
            {
                for (int dx = 0; dx < ratio; dx++)
                {

                }
            }
        }
        int leafIndex = voxelIndex * 15 + isoIdx;
        isoCombinedValues[leafIndex] = sum / count;
    }
}
