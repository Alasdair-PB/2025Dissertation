#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"
#include "PlanetGeneratorHelpers.usf"

int leafDepth;
int nodeIndex; // always 0 ignore each leaf has its own isoCombinedValues buffer, this is left over from before

Buffer<float> isoValues;
Buffer<float> isoDeltaValues;
RWBuffer<float> isoCombinedValues;

Buffer<int> typeValues;
Buffer<int> typeDeltaValues;
RWBuffer<int> typeCombinedValues;

int voxelsPerAxis;
int highResVoxelsPerAxis;

float3 leafPosition;
float3 octreePosition;
float baseDepthScale;

float GetDensity(int3 coord)
{
    float3 p = (float3(coord) / voxelsPerAxis) * 2.0 - 1.0;
    float sphere = length(p) - 0.5;
    return sphere;
}

// Maximum of 8 types supported
int GetMostCommonTypeFromPackedData(uint2 packedData)
{
    uint maxCount = 0;
    uint maxType = 0;

[unroll]
    for (uint i = 0; i < 8; i++)
    {
        uint word = (i < 4) ? packedData.x : packedData.y;
        uint shift = (i % 4) * 8;
        uint count = (word >> shift) & 0xFFu;

        if (count > maxCount)
        {
            maxCount = count;
            maxType = i;
        }
    }
    return maxType;
}

int GetType(int innitType, int deltaType)
{
    return innitType != deltaType && deltaType != 0 ? deltaType : innitType;
}

uint2 PackDataFromType(uint type, uint2 packedCounts)
{
    type = type > 7 ? 0 : type;
    uint shift = (type % 4) * 8;
    uint mask = 0xFFu << shift;
    uint weight = 1;

    if (type < 4)
    {
        uint count = (packedCounts.x & mask) >> shift;
        count = min(count + weight, 255);
        packedCounts.x = (packedCounts.x & ~mask) | (count << shift);
    }
    else
    {
        uint count = (packedCounts.y & mask) >> shift;
        count = min(count + weight, 255);
        packedCounts.y = (packedCounts.y & ~mask) | (count << shift);
    }
    return packedCounts;
}

// 6, 6, 6: (0-5)
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void Deformation(int3 id : SV_DispatchThreadID)
{
    int isoPerAxis = voxelsPerAxis + 1;
    if (any(id >= (isoPerAxis)))
        return;
    
    int isoPerAxisMaxRes = highResVoxelsPerAxis + 1;
    float voxelWorldSize = baseDepthScale / (highResVoxelsPerAxis);
    float ratio = baseDepthScale / 2.0;
    float3 minimumCornerVoxelBodyPos = octreePosition - float3(ratio, ratio, ratio);
    float stride = (highResVoxelsPerAxis / voxelsPerAxis);

    float scale = baseDepthScale / (1 << leafDepth);
    float centerDis = floor(scale / 2);
    float3 leafMinWorld = leafPosition - float3(centerDis, centerDis, centerDis);
    
    float3 offsetWorld = leafMinWorld - minimumCornerVoxelBodyPos;
    float3 offsetVoxelsF = floor(offsetWorld / voxelWorldSize);
    float leafStride = stride / (1 << leafDepth);
    int3 startIndex = (int3) offsetVoxelsF + (id * leafStride);
    
    if (!(leafStride < 1))
    {
        int flat = GetIsoIndex(startIndex, isoPerAxisMaxRes);
        float density = clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
        int type = GetType(typeValues[flat], typeDeltaValues[flat]);
        
        int writeIndex = GetIsoIndex(id, isoPerAxis);
        typeCombinedValues[writeIndex] = type;
        isoCombinedValues[writeIndex] = density;
        return;
    }
    
    //leafStride /= 2;
    int halfStride = floor(leafStride / 2);
    
    /*if (any(id == 0))
    {
        int3 readBufferIndex = startIndex - int3(halfStride, halfStride, halfStride);
        int flat = GetIsoIndex(readBufferIndex, isoPerAxisMaxRes);
        float cornerDensity = clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
        int type = GetType(typeValues[flat], typeDeltaValues[flat]);
        
        int writeIndex = GetIsoIndex(id, isoPerAxis);
        isoCombinedValues[writeIndex] = cornerDensity;
        typeCombinedValues[writeIndex] = type;
        return;
    }   
    
    if (any(id == voxelsPerAxis))
    {
        int3 readBufferIndex = startIndex + int3(halfStride + 1, halfStride + 1, halfStride + 1);
        int flat = GetIsoIndex(readBufferIndex, isoPerAxisMaxRes);
        float cornerDensity = clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
        int type = GetType(typeValues[flat], typeDeltaValues[flat]);
        
        int writeIndex = GetIsoIndex(id, isoPerAxis);
        isoCombinedValues[writeIndex] = cornerDensity;
        typeCombinedValues[writeIndex] = type;
        return;
    }*/
    
    float count = 0.0;
    float sum = 0.0;  
    uint2 packedCounts = uint2(0, 0);

    [loop]
        for (int dz = startIndex.z - halfStride; dz < (startIndex.z + halfStride + 1); dz++)
        {
            for (int dy = startIndex.y - halfStride; dy < (startIndex.y + halfStride + 1); dy++)
            {
                for (int dx = startIndex.x - halfStride; dx < (startIndex.x + halfStride + 1); dx++)
                {
                    int3 readBufferIndex = int3(dx, dy, dz);

                    if (any(readBufferIndex < 0))
                        continue;
                    if (any(readBufferIndex >= isoPerAxisMaxRes))
                        continue;
                    
                    int flat = GetIsoIndex(readBufferIndex, isoPerAxisMaxRes);
                    
                    sum += clamp(isoValues[flat] + isoDeltaValues[flat], 0.0, 1.0);
                    int type = GetType(typeValues[flat], typeDeltaValues[flat]);
                    
                    if (type >= 0 && type < 8)
                        packedCounts = PackDataFromType(type, packedCounts);
                    count++;
                }
            }
        }
    
    int mostCommonType = GetMostCommonTypeFromPackedData(packedCounts);
    float density = sum / count;
    int writeIndex = GetIsoIndex(id, isoPerAxis);
    isoCombinedValues[writeIndex] = density;
    typeCombinedValues[writeIndex] = mostCommonType;
}
                
