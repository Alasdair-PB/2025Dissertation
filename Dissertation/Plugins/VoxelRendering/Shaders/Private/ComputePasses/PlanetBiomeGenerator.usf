#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(PlanetBiomeGenerator)
#include "/Engine/Public/Platform.ush"
#include "PlanetGeneratorHelpers.usf"

int size;
int seed;

float isoLevel;
float baseDepthScale;
float planetScaleRatio;

StructuredBuffer<float> isoValues;
RWStructuredBuffer<int> outTypeValues;

// Rock type = 0
// Surface type = 1
// Core type = 2
// Cliff type = 3

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void PlanetBiomeGenerator(int3 id : SV_DispatchThreadID)
{
    if (any(id >= size))
        return;
    
    int NoiseIndex = GetIsoIndex(id, size);
    float isoValue = isoValues[NoiseIndex];    
    float isoScale = (baseDepthScale / (size));
    float3 position = (id * isoScale) + (isoScale / 2);
    float distance = GetCenterDistance(position, isoScale, size, baseDepthScale);
    float distanceMult = baseDepthScale * clamp(planetScaleRatio, 0.0, 1.0);
    
    distance = clamp(distance / distanceMult, 0, 1);
    int typeValue = 3;  //distance < 0.15 ? 2: 0;
    bool hasAirNeighbor = false;

    [unroll]
    for (int i = 0; i < 6; i++)
    {
        int3 offset = int3(0, 0, 0);
        offset[i % 3] = (i < 3) ? -1 : 1;

        int3 neighbor = id + offset;
        if (any(neighbor < 0) || any(neighbor >= size))
            continue;

        int neighborIdx = GetIsoIndex(neighbor, size);
        float neighborIso = isoValues[neighborIdx];

        if (neighborIso > isoLevel - 0.15) // 0.1
        {
            hasAirNeighbor = true;
            break;
        }
    }
    
    
    if (hasAirNeighbor)
    {
        float3 center = float3(size, size, size) * 0.5;
        float3 voxelPos = id;
        float3 radialDir = normalize(voxelPos - center);

        float3 normal = float3(0, 0, 0);
        [unroll]
        for (int i = 0; i < 3; i++)
        {
            int3 pos = id;
            pos[i]++;
            int3 neg = id;
            neg[i]--;
            if (all(pos < size) && all(neg >= 0))
            {
                float p = isoValues[GetIsoIndex(pos, size)];
                float n = isoValues[GetIsoIndex(neg, size)];
                normal[i] = (p - n) * 0.5;
            }
        }
        normal = normalize(normal);
        float facing = dot(normal, radialDir);

        if (facing > 0.5)
            typeValue = 1; // grass surface
        else
            typeValue = 3; // cliff
    }

    outTypeValues[NoiseIndex] = typeValue;
}
