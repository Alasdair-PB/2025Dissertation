#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"

float3 leafPosition;
int leafDepth;
int nodeIndex;

Buffer<float> isoValues; // 8 isoValues 
Buffer<int> typeValues; // 8 typesValues

Buffer<float> isoAdjValuesA; // 8 isoValues 
Buffer<float> isoAdjValuesB; // 8 isoValues 
Buffer<float> isoAdjValuesC; // 8 isoValues 
Buffer<float> isoAdjValuesD; // 8 isoValues 

Buffer<int> typeAdjValuesA; // 8 typesValues
Buffer<int> typeAdjValuesB; // 8 typesValues
Buffer<int> typeAdjValuesC; // 8 typesValues
Buffer<int> typeAdjValuesD; // 8 typesValues

Buffer<int> transitionLookup;
Buffer<int> flatTransitionVertexData;

RWBuffer<float> outVertexInfo;
RWBuffer<float> outNormalInfo;
RWBuffer<int> outTypeInfo;

int voxelsPerAxis;
float baseDepthScale;
float isoLevel;
int3 direction;
int transitionCellIndex;
int resetNode;

static const int transitionLengths[512] = { 0, 6, 3, 0, 6, 12, 9, 9, 3, 0, 6, 0, 0, 15, 12, 12, 6, 12, 9, 0, 12, 18, 0, 15, 9, 15, 12, 18, 9, 0, 0, 0, 3, 9, 6, 0, 0, 15, 12, 12, 6, 12, 9, 0, 0, 18, 0, 15, 0, 0, 0, 0, 15, 0, 18, 18, 12, 18, 15, 0, 12, 18, 0, 15, 6, 12, 0, 15, 12, 18, 15, 0, 9, 15, 12, 18, 0, 0, 18, 18, 12, 18, 15, 0, 18, 18, 21, 0, 0, 21, 0, 24, 15, 0, 0, 0, 9, 0, 12, 18, 15, 21, 18, 0, 12, 0, 15, 21, 18, 24, 21, 0, 9, 15, 12, 18, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 3, 9, 6, 12, 9, 0, 12, 0, 6, 12, 9, 0, 0, 18, 15, 0, 0, 15, 12, 18, 15, 21, 0, 0, 12, 18, 15, 21, 12, 0, 0, 0, 6, 12, 9, 15, 12, 0, 15, 0, 9, 15, 12, 18, 0, 21, 18, 18, 0, 18, 0, 0, 18, 24, 21, 21, 0, 21, 18, 24, 15, 0, 18, 18, 0, 9, 0, 12, 0, 15, 18, 0, 0, 12, 0, 15, 0, 18, 0, 15, 15, 0, 18, 18, 0, 0, 24, 0, 18, 0, 21, 0, 18, 0, 21, 0, 12, 0, 0, 0, 18, 0, 21, 0, 15, 0, 18, 18, 0, 21, 24, 18, 12, 0, 15, 15, 18, 0, 0, 0, 0, 0, 18, 18, 15, 0, 18, 0, 6, 12, 9, 0, 12, 18, 15, 15, 9, 0, 12, 0, 0, 21, 12, 0, 12, 18, 15, 0, 18, 24, 0, 21, 15, 21, 18, 24, 15, 0, 12, 0, 9, 15, 12, 0, 0, 21, 18, 0, 12, 18, 15, 21, 0, 24, 15, 0, 0, 0, 0, 0, 21, 0, 0, 12, 12, 18, 0, 0, 0, 0, 0, 9, 12, 18, 0, 21, 18, 24, 21, 0, 15, 21, 18, 24, 0, 0, 18, 0, 18, 24, 21, 0, 24, 36, 27, 21, 0, 27, 0, 18, 21, 21, 18, 12, 15, 0, 18, 0, 21, 27, 24, 0, 18, 0, 0, 0, 24, 18, 21, 9, 15, 21, 0, 12, 0, 21, 0, 0, 12, 18, 15, 0, 0, 12, 0, 0, 9, 15, 12, 12, 15, 0, 18, 12, 12, 18, 15, 15, 0, 0, 0, 0, 0, 21, 18, 18, 21, 27, 0, 18, 18, 24, 0, 21, 0, 0, 15, 0, 12, 18, 15, 0, 18, 0, 0, 15, 15, 0, 0, 0, 21, 0, 0, 0, 0, 24, 21, 0, 24, 18, 0, 0, 15, 21, 0, 18, 0, 9, 0, 0, 0, 15, 0, 0, 0, 21, 24, 0, 0, 0, 21, 0, 0, 12, 0, 9, 21, 0, 24, 0, 0, 21, 18, 12, 0, 0, 0, 9, 12, 0, 0, 0, 12, 12, 15, 0, 18, 18, 21, 0, 0, 15, 0, 0, 0, 0, 18, 0, 0, 0, 0, 9, 0, 12, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0 };
static const int transitionOffsets[512] = { 0, 0, 6, 0, 9, 15, 27, 36, 45, 0, 48, 0, 0, 54, 69, 81, 93, 99, 111, 0, 120, 132, 0, 150, 165, 174, 189, 201, 219, 0, 0, 0, 228, 231, 240, 0, 0, 246, 261, 273, 285, 291, 303, 0, 0, 312, 0, 330, 0, 0, 0, 0, 345, 0, 360, 378, 396, 408, 426, 0, 441, 453, 0, 471, 486, 492, 0, 504, 519, 531, 549, 0, 564, 573, 588, 600, 0, 0, 618, 636, 654, 666, 684, 0, 699, 717, 735, 0, 0, 756, 0, 777, 801, 0, 0, 0, 816, 0, 825, 837, 855, 870, 891, 0, 909, 0, 921, 936, 957, 975, 999, 0, 1020, 1029, 1044, 1056, 0, 0, 0, 0, 0, 0, 0, 1074, 0, 0, 0, 0, 1095, 1098, 1107, 1113, 1125, 0, 1134, 0, 1146, 1152, 1164, 0, 0, 1173, 1191, 0, 0, 1206, 1221, 1233, 1251, 1266, 0, 0, 1287, 1299, 1317, 1332, 1353, 0, 0, 0, 1365, 1371, 1383, 1392, 1407, 0, 1419, 0, 1434, 1443, 1458, 1470, 0, 1488, 1509, 1527, 0, 1545, 0, 0, 1563, 1581, 1605, 1626, 0, 1647, 1668, 1686, 1710, 0, 1725, 1743, 0, 1761, 0, 1770, 0, 1782, 1797, 0, 0, 1815, 0, 1827, 0, 1842, 0, 1860, 1875, 0, 1890, 1908, 0, 0, 1926, 0, 1950, 0, 1968, 0, 1989, 0, 2007, 0, 2028, 0, 0, 0, 2040, 0, 2058, 0, 2079, 0, 2094, 2112, 0, 2130, 2151, 2175, 2193, 0, 2205, 2220, 2235, 0, 0, 0, 0, 0, 2253, 2271, 2289, 0, 2304, 0, 2322, 2328, 2340, 0, 2349, 2361, 2379, 2394, 2409, 0, 2418, 0, 0, 2430, 2451, 0, 2463, 2475, 2493, 0, 2508, 2526, 0, 2550, 2571, 2586, 2607, 2625, 2649, 0, 2664, 0, 2676, 2685, 2700, 0, 0, 2712, 2733, 0, 2751, 2763, 2781, 2796, 0, 2817, 2841, 0, 0, 0, 0, 0, 2856, 0, 0, 2877, 2889, 2901, 0, 0, 0, 0, 0, 2919, 2928, 2940, 0, 2958, 2979, 2997, 3021, 0, 3042, 3057, 3078, 3096, 0, 0, 3120, 0, 3138, 3156, 3180, 0, 3201, 3225, 3261, 3288, 0, 3309, 0, 3336, 3354, 3375, 3396, 3414, 3426, 0, 3441, 0, 3459, 3480, 3507, 0, 3531, 0, 0, 0, 3549, 3573, 3591, 3612, 3621, 3636, 0, 3657, 0, 3669, 0, 0, 3690, 3702, 3720, 0, 0, 3735, 0, 0, 3747, 3756, 3771, 3783, 3795, 0, 3810, 3828, 3840, 3852, 3870, 3885, 0, 0, 0, 0, 0, 3900, 3921, 3939, 3957, 3978, 0, 4005, 4023, 4041, 0, 4065, 0, 0, 4086, 0, 4101, 4113, 4131, 0, 4146, 0, 0, 4164, 4179, 0, 0, 0, 4194, 0, 0, 0, 0, 4215, 4239, 0, 4260, 4284, 0, 0, 4302, 4317, 0, 4338, 0, 4356, 0, 0, 0, 4365, 0, 0, 0, 4380, 4401, 0, 0, 0, 4425, 0, 0, 4446, 0, 4458, 4467, 0, 4488, 0, 0, 4512, 4533, 4551, 0, 0, 0, 4563, 4572, 0, 0, 0, 4584, 4596, 4608, 0, 4623, 4641, 4659, 0, 0, 4680, 0, 0, 0, 0, 4695, 0, 0, 0, 0, 4713, 0, 4722, 4734, 0, 0, 0, 0, 0, 4743, 0, 0, 0 };
static const int3 offsets[13] = { int3(0, 0, 0), int3(1, 0, 0), int3(2, 0, 0), int3(0, 1, 0), int3(1, 1, 0), int3(2, 1, 0), int3(0, 2, 0), int3(1, 2, 0), int3(2, 2, 0), int3(0, 0, 2), int3(2, 0, 2), int3(0, 2, 2), int3(2, 2, 2)};

int GetIsoIndex(int3 coord)
{
    int maxIsoCount = (voxelsPerAxis + 1) * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    int index = coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    return max(0, min(index, maxIsoCount - 1)); // 0-35
}

int SetAxisValue(int1 directionAxisVal, int axisModifier, int highAxis)
{
    return ((directionAxisVal.x < 0 ? highAxis : 0) + axisModifier);
}

int3 GetDirectionalIsoIndex(int2 coord, int axisModifier = 0, int highAxis = voxelsPerAxis, int directionMult = 1)
{
    int3 absDir = abs(direction);
    int mainAxis = dot(absDir, int3(0, 1, 2));

    int u = (mainAxis + 1) % 3;
    int v = (mainAxis + 2) % 3;

    int x = 0;
    int y = 0;
    int z = 0;

    if (u == 0)
        x = coord.x;
    else if (v == 0)
        x = coord.y;
    else if (mainAxis == 0)
        x = SetAxisValue(direction.x * directionMult, axisModifier, highAxis);

    if (u == 1)
        y = coord.x;
    else if (v == 1)
        y = coord.y;
    else if (mainAxis == 1)
        y = SetAxisValue(direction.y * directionMult, axisModifier, highAxis);

    if (u == 2)
        z = coord.x;
    else if (v == 2)
        z = coord.y;
    else if (mainAxis == 2)
        z = SetAxisValue(direction.z * directionMult, axisModifier, highAxis);
    return int3(x, y, z);
}

// C, D, A, B seems to be correct
float GetDensityHighY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ?
        isoAdjValuesC[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // C <<
        isoAdjValuesD[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // D
}

float GetDensityLowY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ? 
        isoAdjValuesA[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // A <<
        isoAdjValuesB[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // B
}

// presumes >= 8 coord
float GetTransvoxelLowRes(int2 voxelCoord, int offsetCoord)
{
    voxelCoord.x += (offsets[offsetCoord].x / 2);
    voxelCoord.y += (offsets[offsetCoord].y / 2);

    int3 pos = GetDirectionalIsoIndex(voxelCoord);
    bool isEdge = any(pos < 0) || any(pos > voxelsPerAxis);
    
    return isEdge ? 
        0.0 : 
        isoValues[GetIsoIndex(pos)]; 
}

// presumes < 9 coord
float GetTransvoxelHighRes(int2 voxelCoord, int offsetCoord)
{    
    voxelCoord.x = (voxelCoord.x * 2);
    voxelCoord.y = (voxelCoord.y * 2);
    
    voxelCoord.x += offsets[offsetCoord].x;
    voxelCoord.y += offsets[offsetCoord].y;

    return voxelCoord.y >= voxelsPerAxis ?
            GetDensityHighY((voxelCoord - int2(0, voxelsPerAxis))) :
            GetDensityLowY(voxelCoord);
}

float GetTransvoxelDensity(int2 voxelCoord, int offsetCoord)
{
    return (offsetCoord >= 9) ?
        GetTransvoxelLowRes(voxelCoord, offsetCoord) :
        GetTransvoxelHighRes(voxelCoord, offsetCoord);
}

// Needs refactor
int GetType(int3 coord)
{
    // This is a transvoxel coordinate in 3d- workings below are not accurate
    bool isEdge = any(coord < 0) || any(coord > voxelsPerAxis);
    return isEdge ? 0 : typeValues[(GetIsoIndex(coord))];
}

bool DebugTriangleOnCondition(int a, int b, int k, int vertexFloatIndex, int vertexStartIndex, float isoScale, float3 worldPos, int2 voxelCoords)
{
    //  if (length % 3 != 0) // Length count check
    if (a > 12 || b > 12) // EdgeCode index check
    {
        float2 A = float2(0.0, 1.0);
        float2 B = float2(1.0, 1.0);
        float2 C = float2(0.0, 0.0);
        float2 D = float2(1.0, 0.0);
        
        float x = k % 3 == 0 ? A.x : k % 3 == 1 ? B.x : C.x;
        float y = k % 3 == 0 ? A.y : k % 3 == 1 ? B.y : C.y;

        //if (k % 3 == 0 && k > 2)  
        /* Triangle check:
        outVertexInfo[vertexFloatIndex - 3] == p0.x &&
        outVertexInfo[vertexFloatIndex - 2] == p0.y &&
        outVertexInfo[vertexFloatIndex - 1] == p0.z &&
        outVertexInfo[vertexFloatIndex - 6] == p0.x &&
        outVertexInfo[vertexFloatIndex - 5] == p0.y &&
        outVertexInfo[vertexFloatIndex - 4] == p0.z)*/
        //{
        
        int2 deltaCoord;
        deltaCoord.x = x + voxelCoords.x;
        deltaCoord.y = y + voxelCoords.y;

        float3 position = GetDirectionalIsoIndex(deltaCoord); // isoscale
        outVertexInfo[vertexFloatIndex] = position.x + worldPos.x;
        outVertexInfo[vertexFloatIndex + 1] = (position.y * 300) + worldPos.y;
        outVertexInfo[vertexFloatIndex + 2] = position.z + worldPos.z;
        outTypeInfo[vertexStartIndex + k] = 1;
        return true;

        //}
    }
    return false;
}

// x, y, 0
// Use id as int2 as z value is 0. 
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void TransvoxelMarchingCubes(int3 id : SV_DispatchThreadID)
{
    if (any(id >= voxelsPerAxis)) return;
    
     int transitionCellMarchIndex = (id.x * voxelsPerAxis) + id.y;
    int maxedCount = (voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) * 15;
    int totalMarchCellsPerTransitionCell = voxelsPerAxis * voxelsPerAxis;
    int flatIndex = (transitionCellIndex * totalMarchCellsPerTransitionCell) + transitionCellMarchIndex;
    int vertexStartIndex = maxedCount + (flatIndex * 36);
    
    float scale = baseDepthScale / (1 << (leafDepth)); // 400/(2 or 4) => 200 or 100
    float modScale = baseDepthScale / (1 << (leafDepth + 1)); // 400/(2 or 4) => 200 or 100

    float centerDis = scale / 2.0; // 100, 50
    float isoScale = (scale / (voxelsPerAxis)); // 10 or 5
    float isoDetailScale = (modScale / (voxelsPerAxis)); // 10 or 5

    float3 minimumCornerWorldPos = leafPosition - float3(centerDis, centerDis, centerDis);
    
    for (int j = 0; j < 36; j++)
    {
        uint vertexFloatIndex = (vertexStartIndex + j) * 3;
        outVertexInfo[vertexFloatIndex] = 0.0;
        outVertexInfo[vertexFloatIndex + 1] = 0.0;
        outVertexInfo[vertexFloatIndex + 2] = 0.0;
        outTypeInfo[vertexStartIndex + j] = 0;
    }
    
    if (resetNode > 0) return;
    
    int2 transVoxelCoord = int2(id.x, id.y);
    int3 inDir = int3(direction.x, direction.y, direction.z);
    
    float _trCellValues[13];
    _trCellValues[0] = GetTransvoxelDensity(transVoxelCoord, 0); //_trCellValues[9];
    _trCellValues[2] = GetTransvoxelDensity(transVoxelCoord, 2); //_trCellValues[10];
    _trCellValues[6] = GetTransvoxelDensity(transVoxelCoord, 6); //_trCellValues[11];
    _trCellValues[8] = GetTransvoxelDensity(transVoxelCoord, 8); //_trCellValues[12]; 
    
    _trCellValues[1] = GetTransvoxelDensity(transVoxelCoord, 1);
    _trCellValues[3] = GetTransvoxelDensity(transVoxelCoord, 3);
    _trCellValues[4] = GetTransvoxelDensity(transVoxelCoord, 4);
    _trCellValues[5] = GetTransvoxelDensity(transVoxelCoord, 5);
    _trCellValues[7] = GetTransvoxelDensity(transVoxelCoord, 7);
    
    _trCellValues[9] = GetTransvoxelDensity(transVoxelCoord, 9); // _trCellValues[0];
    _trCellValues[10] = GetTransvoxelDensity(transVoxelCoord, 10); // _trCellValues[2];
    _trCellValues[11] = GetTransvoxelDensity(transVoxelCoord, 11); //_trCellValues[6];
    _trCellValues[12] = GetTransvoxelDensity(transVoxelCoord, 12); //_trCellValues[8];
    
    
    /*int caseCode = ((
        _trCellValues[9] < isoLevel ? 1 : 0)
        | (_trCellValues[1] < isoLevel ? 2 : 0)
        | (_trCellValues[10] < isoLevel ? 4 : 0)
        | (_trCellValues[3] < isoLevel ? 8 : 0)
        | (_trCellValues[4] < isoLevel ? 16 : 0)
        | (_trCellValues[5] < isoLevel ? 32 : 0)
        | (_trCellValues[11] < isoLevel ? 64 : 0)
        | (_trCellValues[7] < isoLevel ? 128 : 0)
        | (_trCellValues[12] < isoLevel ? 256 : 0)
    );*/
    
    /*int caseCode = (
        (_trCellValues[0] < isoLevel ? 1 : 0)
        | (_trCellValues[1] < isoLevel ? 2 : 0)
        | (_trCellValues[2] < isoLevel ? 4 : 0)
        | (_trCellValues[5] < isoLevel ? 8 : 0)
        | (_trCellValues[8] < isoLevel ? 16 : 0)
        | (_trCellValues[7] < isoLevel ? 32 : 0)
        | (_trCellValues[6] < isoLevel ? 64 : 0)
        | (_trCellValues[3] < isoLevel ? 128 : 0)
        | (_trCellValues[4] < isoLevel ? 256 : 0));
    */
    int caseCode = ((_trCellValues[9] < 0 ? 1 : 0)
        | (_trCellValues[1] < isoLevel ? 2 : 0)
        | (_trCellValues[10] < isoLevel ? 4 : 0)
        | (_trCellValues[5] < isoLevel ? 8 : 0)
        | (_trCellValues[12] < isoLevel ? 16 : 0)
        | (_trCellValues[7] < isoLevel ? 32 : 0)
        | (_trCellValues[11] < isoLevel ? 64 : 0)
        | (_trCellValues[3] < isoLevel ? 128 : 0)
        | (_trCellValues[4] < isoLevel ? 256 : 0));

    int3 voxelCoord = GetDirectionalIsoIndex(int2(id.x, id.y)) * isoScale;
    int offset = transitionOffsets[caseCode];
    int length = transitionLengths[caseCode]; //0-511
    
    if (caseCode == 0 || caseCode == 511)
    {
        return;
    }
    
    for (uint k = 0; k < length; k++) // Up to 0-24 
    {
        uint vertexFloatIndex = (vertexStartIndex + k) * 3;
        uint edgeCode = flatTransitionVertexData[caseCode * 12 + k];

        uint a = (edgeCode >> 4) & 0x0F;
        uint b = edgeCode & 0x0F;
        
        //if (DebugTriangleOnCondition(a, b, k, vertexFloatIndex, vertexStartIndex, isoScale, minimumCornerWorldPos, int2(id.x, id.y)))
        //    continue;
        
        int2 positionA = int2(offsets[a].x, offsets[a].y);
        int3 positionAxisAlignedA = GetDirectionalIsoIndex(positionA, 0, 0); //offsets[a].z
        
        int2 positionB = int2(offsets[b].x, offsets[b].y);
        int3 positionAxisAlignedB = GetDirectionalIsoIndex(positionB, 0, 0); //offsets[b].z
        
        float3 pa = float3(positionAxisAlignedA.x, positionAxisAlignedA.y, positionAxisAlignedA.z);
        float3 pb = float3(positionAxisAlignedB.x, positionAxisAlignedB.y, positionAxisAlignedB.z);

        float densityA = _trCellValues[a];
        float densityB = _trCellValues[b];
        
        float3 position = pa;
        if ((densityA < isoLevel) != (densityB < isoLevel))
        {
            float denom = densityB - densityA;
            float t = (isoLevel - densityA) / denom;
            position = pa + t * (pb - pa);
        }
        else
        {
            if (densityA < isoLevel)
                position = pa;
            else if (densityB < isoLevel)
                position = pb;
            else
                position = float3(0, 0, 0);

        }
        position *= isoDetailScale;
        position += voxelCoord;
        
        outVertexInfo[vertexFloatIndex] = position.x + minimumCornerWorldPos.x;
        outVertexInfo[vertexFloatIndex + 1] = position.y + minimumCornerWorldPos.y;
        outVertexInfo[vertexFloatIndex + 2] = position.z + minimumCornerWorldPos.z;
        outTypeInfo[vertexStartIndex + k] = 0;
    }
}

        