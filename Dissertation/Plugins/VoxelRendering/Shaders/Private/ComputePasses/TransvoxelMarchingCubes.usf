#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"

float3 leafPosition;
int leafDepth;
int nodeIndex;

Buffer<float> isoValues; // 8 isoValues 
Buffer<int> typeValues; // 8 typesValues

Buffer<float> isoAdjValuesA; // 8 isoValues 
Buffer<float> isoAdjValuesB; // 8 isoValues 
Buffer<float> isoAdjValuesC; // 8 isoValues 
Buffer<float> isoAdjValuesD; // 8 isoValues 

Buffer<int> typeAdjValuesA; // 8 typesValues
Buffer<int> typeAdjValuesB; // 8 typesValues
Buffer<int> typeAdjValuesC; // 8 typesValues
Buffer<int> typeAdjValuesD; // 8 typesValues

Buffer<int> transitionLookup;
Buffer<int> flatTransitionVertexData;

RWBuffer<float> outVertexInfo;
RWBuffer<float> outNormalInfo;
RWBuffer<int> outTypeInfo;

int voxelsPerAxis;
float baseDepthScale;
float isoLevel;
int3 direction;
int transitionCellIndex;
int resetNode;

static const int transitionCornerIndexAFromEdge[13] = { 3, 2, 2, 1, 4, 8, 1, 8, 8, 3, 2, 1, 8 };
static const int transitionCornerIndexBFromEdge[13] = { 0, 1, 0, 2, 0, 2, 0, 1, 0, 7, 7, 7, 7 };
static const int transitionLengths[512] = { 0, 6, 3, 9, 6, 12, 9, 9, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 9, 15, 12, 12, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 12, 18, 15, 15, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 18, 21, 15, 15, 21, 18, 24, 15, 15, 18, 12, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 21, 21, 9, 15, 12, 18, 15, 15, 18, 12, 12, 18, 15, 21, 12, 12, 15, 9, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 12, 18, 15, 15, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 15, 21, 18, 18, 9, 9, 12, 12, 15, 15, 18, 12, 12, 12, 15, 15, 18, 18, 21, 15, 15, 15, 18, 18, 21, 15, 24, 12, 18, 18, 21, 21, 18, 12, 21, 9, 12, 12, 15, 15, 18, 18, 21, 15, 15, 15, 18, 18, 21, 21, 24, 18, 12, 12, 15, 15, 18, 12, 21, 9, 15, 15, 18, 18, 15, 9, 18, 6, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 12, 12, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 15, 21, 12, 12, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 15, 15, 15, 21, 18, 24, 21, 27, 12, 12, 12, 18, 15, 21, 12, 18, 9, 9, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 21, 27, 18, 18, 18, 24, 21, 27, 24, 36, 27, 21, 21, 27, 24, 18, 21, 21, 18, 12, 15, 21, 18, 12, 21, 27, 24, 12, 18, 24, 21, 15, 24, 18, 21, 9, 15, 21, 18, 12, 21, 21, 12, 6, 12, 18, 15, 9, 12, 12, 9, 3, 9, 15, 12, 12, 15, 21, 18, 12, 12, 18, 15, 15, 18, 12, 15, 9, 15, 21, 18, 18, 21, 27, 24, 18, 18, 24, 21, 21, 18, 12, 15, 9, 12, 18, 15, 15, 18, 24, 21, 15, 15, 21, 18, 18, 21, 15, 18, 12, 18, 24, 21, 21, 24, 18, 15, 9, 15, 21, 18, 18, 15, 9, 12, 6, 15, 15, 18, 12, 21, 21, 24, 12, 18, 18, 21, 15, 24, 12, 21, 9, 21, 21, 24, 18, 27, 21, 18, 12, 12, 12, 15, 9, 12, 6, 9, 3, 12, 12, 15, 9, 18, 18, 21, 9, 15, 15, 18, 12, 21, 9, 18, 6, 12, 12, 15, 9, 18, 12, 9, 3, 9, 9, 12, 6, 9, 3, 6, 0 };
static const int transitionOffsets[512] = { 0, 0, 6, 9, 18, 24, 36, 45, 54, 57, 66, 72, 84, 93, 108, 120, 132, 138, 150, 159, 174, 186, 204, 219, 234, 243, 258, 270, 288, 297, 312, 324, 336, 339, 348, 354, 366, 375, 390, 402, 414, 420, 432, 441, 456, 468, 486, 501, 516, 525, 540, 552, 570, 585, 606, 624, 642, 654, 672, 687, 708, 720, 738, 753, 768, 774, 786, 795, 810, 822, 840, 855, 870, 879, 894, 906, 924, 939, 960, 978, 996, 1008, 1026, 1041, 1062, 1080, 1098, 1119, 1134, 1149, 1170, 1188, 1212, 1227, 1242, 1260, 1272, 1281, 1296, 1308, 1326, 1341, 1362, 1380, 1398, 1410, 1428, 1443, 1464, 1482, 1506, 1527, 1548, 1557, 1572, 1584, 1602, 1617, 1632, 1650, 1662, 1674, 1692, 1707, 1728, 1740, 1752, 1767, 1776, 1779, 1788, 1794, 1806, 1815, 1830, 1842, 1854, 1860, 1872, 1881, 1896, 1908, 1926, 1941, 1956, 1965, 1980, 1992, 2010, 2025, 2046, 2064, 2082, 2094, 2112, 2127, 2148, 2160, 2178, 2193, 2208, 2214, 2226, 2235, 2250, 2262, 2280, 2295, 2310, 2319, 2334, 2346, 2364, 2379, 2400, 2418, 2436, 2448, 2466, 2481, 2502, 2520, 2544, 2565, 2586, 2601, 2622, 2640, 2664, 2679, 2700, 2718, 2736, 2745, 2754, 2766, 2778, 2793, 2808, 2826, 2838, 2850, 2862, 2877, 2892, 2910, 2928, 2949, 2964, 2979, 2994, 3012, 3030, 3051, 3066, 3090, 3102, 3120, 3138, 3159, 3180, 3198, 3210, 3231, 3240, 3252, 3264, 3279, 3294, 3312, 3330, 3351, 3366, 3381, 3396, 3414, 3432, 3453, 3474, 3498, 3516, 3528, 3540, 3555, 3570, 3588, 3600, 3621, 3630, 3645, 3660, 3678, 3696, 3711, 3720, 3738, 3744, 3750, 3762, 3771, 3786, 3798, 3816, 3831, 3846, 3855, 3870, 3882, 3900, 3915, 3936, 3948, 3960, 3972, 3990, 4005, 4026, 4044, 4068, 4089, 4110, 4125, 4146, 4164, 4188, 4203, 4224, 4236, 4248, 4257, 4272, 4284, 4302, 4317, 4338, 4356, 4374, 4386, 4404, 4419, 4440, 4458, 4482, 4497, 4512, 4527, 4548, 4566, 4590, 4611, 4638, 4650, 4662, 4674, 4692, 4707, 4728, 4740, 4758, 4767, 4776, 4788, 4806, 4821, 4842, 4860, 4884, 4905, 4926, 4941, 4962, 4980, 5004, 5025, 5052, 5070, 5088, 5106, 5130, 5151, 5178, 5202, 5238, 5265, 5286, 5307, 5334, 5358, 5376, 5397, 5418, 5436, 5448, 5463, 5484, 5502, 5514, 5535, 5562, 5586, 5598, 5616, 5640, 5661, 5676, 5700, 5718, 5739, 5748, 5763, 5784, 5802, 5814, 5835, 5856, 5868, 5874, 5886, 5904, 5919, 5928, 5940, 5952, 5961, 5964, 5973, 5988, 6000, 6012, 6027, 6048, 6066, 6078, 6090, 6108, 6123, 6138, 6156, 6168, 6183, 6192, 6207, 6228, 6246, 6264, 6285, 6312, 6336, 6354, 6372, 6396, 6417, 6438, 6456, 6468, 6483, 6492, 6504, 6522, 6537, 6552, 6570, 6594, 6615, 6630, 6645, 6666, 6684, 6702, 6723, 6738, 6756, 6768, 6786, 6810, 6831, 6852, 6876, 6894, 6909, 6918, 6933, 6954, 6972, 6990, 7005, 7014, 7026, 7032, 7047, 7062, 7080, 7092, 7113, 7134, 7158, 7170, 7188, 7206, 7227, 7242, 7266, 7278, 7299, 7308, 7329, 7350, 7374, 7392, 7419, 7440, 7458, 7470, 7482, 7494, 7509, 7518, 7530, 7536, 7545, 7548, 7560, 7572, 7587, 7596, 7614, 7632, 7653, 7662, 7677, 7692, 7710, 7722, 7743, 7752, 7770, 7776, 7788, 7800, 7815, 7824, 7842, 7854, 7863, 7866, 7875, 7884, 7896, 7902, 7911, 7914, 7920 };
static const int3 offsets[13] = { int3(0, 0, 0), int3(1, 0, 0), int3(2, 0, 0), int3(0, 1, 0), int3(1, 1, 0), int3(2, 1, 0), int3(0, 2, 0), int3(1, 2, 0), int3(2, 2, 0), int3(0, 0, 2), int3(2, 0, 2), int3(0, 2, 2), int3(2, 2, 2)};

int GetIsoIndex(int3 coord)
{
    int maxIsoCount = (voxelsPerAxis + 1) * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    int index = coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    return max(0, min(index, maxIsoCount)); // 0-35
}

int SetAxisValue(int1 directionAxisVal, int axisModifier, int highAxis)
{
    return ((directionAxisVal.x < 0 ? highAxis : 0) + axisModifier);
}

float3 GetDirectionalVector(float2 coord, float axisModifier = 0, int directionMult = 1)
{
    int3 absDir = abs(direction);
    int mainAxis = dot(absDir, int3(0, 1, 2));

    int u = (mainAxis + 1) % 3;
    int v = (mainAxis + 2) % 3;

    float x = 0;
    float y = 0;
    float z = 0;

    if (u == 0)
        x = coord.x;
    else if (v == 0)
        x = coord.y;
    else if (mainAxis == 0)
        x = SetAxisValue(direction.x * directionMult, axisModifier, 0);

    if (u == 1)
        y = coord.x;
    else if (v == 1)
        y = coord.y;
    else if (mainAxis == 1)
        y = SetAxisValue(direction.y * directionMult, axisModifier, 0);

    if (u == 2)
        z = coord.x;
    else if (v == 2)
        z = coord.y;
    else if (mainAxis == 2)
        z = SetAxisValue(direction.z * directionMult, axisModifier, 0);
    return float3(x, y, z);
}

int3 GetDirectionalIsoIndex(int2 coord, int axisModifier = 0, int highAxis = voxelsPerAxis, int directionMult = 1)
{
    int3 absDir = abs(direction);
    int mainAxis = dot(absDir, int3(0, 1, 2));

    int u = (mainAxis + 1) % 3;
    int v = (mainAxis + 2) % 3;

    int x = 0;
    int y = 0;
    int z = 0;

    if (u == 0)
        x = coord.x;
    else if (v == 0)
        x = coord.y;
    else if (mainAxis == 0)
        x = SetAxisValue(direction.x * directionMult, axisModifier, highAxis);

    if (u == 1)
        y = coord.x;
    else if (v == 1)
        y = coord.y;
    else if (mainAxis == 1)
        y = SetAxisValue(direction.y * directionMult, axisModifier, highAxis);

    if (u == 2)
        z = coord.x;
    else if (v == 2)
        z = coord.y;
    else if (mainAxis == 2)
        z = SetAxisValue(direction.z * directionMult, axisModifier, highAxis);
    return int3(x, y, z);
}

// Iso Index Helper Functions *************************************************************

// C, D, A, B are correct
float GetDensityHighY(int2 transVoxelCoord, int axisMod = 0)
{
    return transVoxelCoord.x < voxelsPerAxis ?
        isoAdjValuesC[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, axisMod, voxelsPerAxis, -1))] : // C <<
        isoAdjValuesD[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), axisMod, voxelsPerAxis, -1))]; // D
}

float GetDensityLowY(int2 transVoxelCoord, int axisMod = 0)
{
    return transVoxelCoord.x < voxelsPerAxis ? 
        isoAdjValuesA[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, axisMod, voxelsPerAxis, -1))] : // A <<
        isoAdjValuesB[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), axisMod, voxelsPerAxis, -1))]; // B
}

// presumes >= 9 coord
float GetTransvoxelLowRes(int2 voxelCoord, int offsetCoord)
{
    voxelCoord.x += (offsets[offsetCoord].x / 2); // 0 or 2 -> 1/2
    voxelCoord.y += (offsets[offsetCoord].y / 2);

    int3 pos = GetDirectionalIsoIndex(voxelCoord, 0, voxelsPerAxis, 1);
    return isoValues[GetIsoIndex(pos)]; 
}

// presumes < 9 coord
float GetTransvoxelHighRes(int2 voxelCoord, int offsetCoord)
{    
    voxelCoord.x = (voxelCoord.x * 2);
    voxelCoord.y = (voxelCoord.y * 2);
    
    voxelCoord.x += offsets[offsetCoord].x;
    voxelCoord.y += offsets[offsetCoord].y;

    return voxelCoord.y >= voxelsPerAxis ?
        GetDensityHighY((voxelCoord - int2(0, voxelsPerAxis))) :
        GetDensityLowY(voxelCoord);
}

float GetTransvoxelDensity(int2 voxelCoord, int offsetCoord)
{
    return (offsetCoord >= 9) ?
        GetTransvoxelLowRes(voxelCoord, offsetCoord) :
        GetTransvoxelHighRes(voxelCoord, offsetCoord);
}


// Type Index Helper Functions *************************************************************

int GetTypeHighY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ?
        typeAdjValuesC[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // C <<
        typeAdjValuesD[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // D
}

int GetTypeLowY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ?
        typeAdjValuesA[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // A <<
        typeAdjValuesB[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // B
}

// presumes >= 9 coord
int GetTransvoxelTypeLowRes(int2 voxelCoord, int offsetCoord)
{
    voxelCoord.x += (offsets[offsetCoord].x / 2); // 0 or 2 -> 1/2
    voxelCoord.y += (offsets[offsetCoord].y / 2);

    int3 pos = GetDirectionalIsoIndex(voxelCoord, 0, voxelsPerAxis, 1);
    return typeValues[GetIsoIndex(pos)];
}

// presumes < 9 coord
int GetTransvoxelTypeHighRes(int2 voxelCoord, int offsetCoord)
{
    voxelCoord.x = (voxelCoord.x * 2);
    voxelCoord.y = (voxelCoord.y * 2);
    
    voxelCoord.x += offsets[offsetCoord].x;
    voxelCoord.y += offsets[offsetCoord].y;

    return voxelCoord.y >= voxelsPerAxis ?
        GetTypeHighY((voxelCoord - int2(0, voxelsPerAxis))) :
        GetTypeLowY(voxelCoord);
}

int GetTransvoxelType(int2 voxelCoord, int offsetCoord)
{
    return (offsetCoord >= 9) ?
        GetTransvoxelTypeLowRes(voxelCoord, offsetCoord) :
        GetTransvoxelTypeHighRes(voxelCoord, offsetCoord);
}

// Vertex setting ********************************************

float3 ZeroAxisInDirection(float3 position)
{
    int3 zeroAxis = GetDirectionalIsoIndex(int2(1, 1), 0, 0);
    float3 zeroFAxis = float3(zeroAxis.x, zeroAxis.y, zeroAxis.z);
    position *= zeroFAxis;
    return position;
}

float GetDensityOnFace(int2 voxelPosition, bool isHighRes)
{
    if (isHighRes)
    {
        int3 pos = GetDirectionalIsoIndex((voxelPosition / 2), 0, voxelsPerAxis, 1);
        return isoValues[GetIsoIndex(pos)];
    }
    else
    {
        return voxelPosition.y >= voxelsPerAxis ?
            GetDensityHighY((voxelPosition - int2(0, voxelsPerAxis))) :
            GetDensityLowY(voxelPosition);
    }
}

float GetDensityWithFaceOffset(int2 voxelPosition, bool isHighRes, int axisMod, bool onAxis)
{
    if (onAxis)
    {
        if (isHighRes)
        {
            int3 pos = GetDirectionalIsoIndex((voxelPosition / 2), axisMod, voxelsPerAxis, 1);
            return isoValues[GetIsoIndex(pos)];
        }
        else
        {
            return voxelPosition.y >= voxelsPerAxis ?
            GetDensityHighY((voxelPosition - int2(0, voxelsPerAxis)), axisMod) :
            GetDensityLowY(voxelPosition, axisMod);
        }
    } else
    { // Switch to adjacent face buffer
        if (isHighRes)
        {
            return voxelPosition.y >= voxelsPerAxis ?
            GetDensityHighY((voxelPosition - int2(0, voxelsPerAxis)), -axisMod) :
            GetDensityLowY(voxelPosition, -axisMod);
        }
        else
        {
            int3 pos = GetDirectionalIsoIndex((voxelPosition / 2), -axisMod, voxelsPerAxis, 1);
            return isoValues[GetIsoIndex(pos)];
        }
    }
}

float3 CalculateNormal(int2 coord, int3 coordXYZ, bool isHighRes)
{
    int3 lengthVector = coordXYZ * direction;
    int length = (lengthVector.x + coordXYZ.y + coordXYZ.z) / 2; // In low res coords
    
    int2 offsetX = int2(1, 0);
    int2 offsetY = int2(0, 1);
    
    int3 offsetVX = GetDirectionalIsoIndex(offsetX, 0, 0, isHighRes ? 1 : -1);
    int3 offsetVY = GetDirectionalIsoIndex(offsetY, 0, 0, isHighRes >= 9 ? 1 : -1);
    int3 offsetZ = isHighRes ? -direction : direction;
    
    int zOffsetLength = offsetZ.x + offsetZ.y + offsetZ.z;
    int dirOffset = zOffsetLength + length;
    bool onAxis = dirOffset < voxelsPerAxis || dirOffset >= 0;

    float dx = GetDensityOnFace(coord + offsetX, isHighRes) - GetDensityOnFace(coord - offsetX, isHighRes);
    float dy = GetDensityOnFace(coord + offsetY, isHighRes) - GetDensityOnFace(coord - offsetY, isHighRes);
    float dz = GetDensityWithFaceOffset(coord, isHighRes, zOffsetLength, onAxis) - GetDensityWithFaceOffset(coord, isHighRes, zOffsetLength, !onAxis);
    
    float3 delta = GetDirectionalVector(float2(dx, dy), dz, -1);
    return all(delta == 0) ? float3(0.0f, 0.0f, 0.0f) : normalize(float3(dx, dy, dz));
}

void AssignVertexInfo(float3 position, float3 normalRes, int typeFinal, int k, int vertexStartIndex)
{
    uint vertexFloatIndex = (vertexStartIndex + k) * 3;

    outVertexInfo[vertexFloatIndex] = position.x;
    outVertexInfo[vertexFloatIndex + 1] = position.y;
    outVertexInfo[vertexFloatIndex + 2] = position.z;
    
    outNormalInfo[vertexFloatIndex] = normalRes.x;
    outNormalInfo[vertexFloatIndex + 1] = normalRes.y;
    outNormalInfo[vertexFloatIndex + 2] = normalRes.z;
    outTypeInfo[vertexStartIndex + k] = typeFinal;
}

void InterpolateVertice(uint edgeCode, int2 transVoxelCoord, float isoDetailScale, float isoScale, float3 worldPos, float _trCellValues[13], int _trCellTypeValues[13], 
out float3 position, out float3 normalRes, out int typeFinal, out float lowResDensity, out float highResDensity)
{
    uint a = (edgeCode >> 4) & 0x0F;
    uint b = edgeCode & 0x0F;
    
    bool isAHighRes = a >= 9;
    bool isBHighRes = b >= 9;
    
    float densityA = _trCellValues[a];
    float densityB = _trCellValues[b];
    
    highResDensity = 0;
    lowResDensity = 0;
    isAHighRes ? highResDensity += densityA : lowResDensity += densityA;
    isBHighRes ? highResDensity += densityB : lowResDensity += densityB;

    int2 positionA = int2(offsets[a].x + (transVoxelCoord.x * 2), offsets[a].y + (transVoxelCoord.y * 2));
    int2 positionB = int2(offsets[b].x + (transVoxelCoord.x * 2), offsets[b].y + (transVoxelCoord.y * 2));
    
    int3 positionAxisAlignedA = GetDirectionalIsoIndex(positionA, 0, (voxelsPerAxis * 2)); // offsets[a].z if non-zero transcell distance
    int3 positionAxisAlignedB = GetDirectionalIsoIndex(positionB, 0, (voxelsPerAxis * 2)); // offsets[b].z 
    float3 normalA = float3(0, 0, 0); //CalculateNormal(positionA, positionAxisAlignedA, a);
    float3 normalB = float3(0, 0, 0); //= CalculateNormal(positionB, positionAxisAlignedB, b);
    
    float3 pa = worldPos + (float3(positionAxisAlignedA.x, positionAxisAlignedA.y, positionAxisAlignedA.z) * isoDetailScale);
    float3 pb = worldPos + (float3(positionAxisAlignedB.x, positionAxisAlignedB.y, positionAxisAlignedB.z) * isoDetailScale);
    
    float denom = densityB - densityA;
    float t = 0;
    
    if (abs(denom) < 0.01)
    {
        if (isAHighRes || isBHighRes)
            t = (densityA > isoLevel ? 0.5 : 0.5);
        else
            t = (densityA > isoLevel ? 0.5 : 0.5);
    }
    else
        t = (isoLevel - densityA) / denom;
    
     t = clamp(t, -1.0, 1.0);
    normalRes = lerp(normalA, normalB, t);
    position = lerp(pa, pb, t);
    
    int typeA = _trCellTypeValues[a];
    int typeB = _trCellTypeValues[b];
    typeFinal = densityA < densityB ? typeA : typeB;
}

// x, y, 1
[numthreads(8, 8, 1)]
void TransvoxelMarchingCubes(int3 id : SV_DispatchThreadID)
{
    if (any(id >= voxelsPerAxis)) return;
    
    int transitionCellMarchIndex = (id.x * voxelsPerAxis) + id.y;
    int maxedCount = (voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) * 15;
    int totalMarchCellsPerTransitionCell = voxelsPerAxis * voxelsPerAxis;
    int flatIndex = (transitionCellIndex * totalMarchCellsPerTransitionCell) + transitionCellMarchIndex;
    int vertexStartIndex = maxedCount + (flatIndex * 36);
    
    float scale = baseDepthScale / (1 << (leafDepth));
    float modScale = baseDepthScale / (1 << (leafDepth + 1));

    float centerDis = scale / 2.0;
    float isoScale = (scale / (voxelsPerAxis));
    float isoDetailScale = (modScale / (voxelsPerAxis));

    float3 minimumCornerWorldPos = leafPosition - float3(centerDis, centerDis, centerDis);
    
    for (int j = 0; j < 36; j ++)
    {
        uint vertexFloatIndex = (vertexStartIndex + j) * 3;
        outVertexInfo[vertexFloatIndex] = 0.0;
        outVertexInfo[vertexFloatIndex + 1] = 0.0;
        outVertexInfo[vertexFloatIndex + 2] = 0.0;
        
        outNormalInfo[vertexFloatIndex] = 0.0;
        outNormalInfo[vertexFloatIndex + 1] = 0.0;
        outNormalInfo[vertexFloatIndex + 2] = 0.0;
    }
    
    if (resetNode > 0) return;
    int2 transVoxelCoord = int2(id.x, id.y);
    
    float _trCellValues[13];
    int _triCellTypeValues[13];

    for (int i = 0; i < 13; i++)
    {
        _trCellValues[i] = GetTransvoxelDensity(transVoxelCoord, i);
        _triCellTypeValues[i] = GetTransvoxelType(transVoxelCoord, i);
    }
    
    int caseCode = (
        (_trCellValues[0] < isoLevel ? 1 : 0)
        | (_trCellValues[1] < isoLevel ? 2 : 0)
        | (_trCellValues[2] < isoLevel ? 4 : 0)
        | (_trCellValues[5] < isoLevel ? 8 : 0)
        | (_trCellValues[8] < isoLevel ? 16 : 0)
        | (_trCellValues[7] < isoLevel ? 32 : 0)
        | (_trCellValues[6] < isoLevel ? 64 : 0)
        | (_trCellValues[3] < isoLevel ? 128 : 0)
        | (_trCellValues[4] < isoLevel ? 256 : 0));
    
    int3 voxelCoord = GetDirectionalIsoIndex(transVoxelCoord);
    float3 voxelPosition = float3(voxelCoord.x, voxelCoord.y, voxelCoord.z) * isoScale;
    int offset = transitionOffsets[caseCode]; //7920 max item
    int length = transitionLengths[caseCode];    
    
    if (caseCode == 0 || caseCode == 511)
        return;
    
    int directionMagnitude = direction.x + direction.y + direction.z;
    bool directionPriority = directionMagnitude > 0;

    bool switchOrder = false;
    for (uint k = 0; k < length; k += 3) // Up to 0-24 
    {
        uint startVertexIndex = caseCode * 12;
        uint edgeCodeA = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k]];
        uint edgeCodeB = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k + 1]];
        uint edgeCodeC = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k + 2]];
        
        float3 positionA = float3(0.0, 0.0, 0.0);
        float3 positionB = float3(0.0, 0.0, 0.0);
        float3 positionC = float3(0.0, 0.0, 0.0);
        float3 normalResA = float3(0.0, 0.0, 0.0);
        float3 normalResB = float3(0.0, 0.0, 0.0);
        float3 normalResC = float3(0.0, 0.0, 0.0);
        
        int typeA = 0;
        int typeB = 0;
        int typeC = 0;
        
        float densityLowA = 0.0;
        float densityHighA = 0.0;
        float densityLowB = 0.0;
        float densityHighB = 0.0;
        float densityLowC = 0.0;
        float densityHighC = 0.0;
        
        InterpolateVertice(edgeCodeA, transVoxelCoord, isoDetailScale, isoScale, minimumCornerWorldPos, _trCellValues, _triCellTypeValues, positionA, normalResA, typeA, densityLowA, densityHighA);
        InterpolateVertice(edgeCodeB, transVoxelCoord, isoDetailScale, isoScale, minimumCornerWorldPos, _trCellValues, _triCellTypeValues, positionB, normalResB, typeB, densityLowB, densityHighB);
        InterpolateVertice(edgeCodeC, transVoxelCoord, isoDetailScale, isoScale, minimumCornerWorldPos, _trCellValues, _triCellTypeValues, positionC, normalResC, typeC, densityLowC, densityHighC);
        
        float lowDensity = densityLowA + densityLowB + densityLowC;
        float highDensity = densityHighA + densityHighB + densityHighC;
        bool switchOnDensity = lowDensity + 0.01 > highDensity;
        
        int3 order = true ? int3(0, 1, 2) : int3(2, 1, 0);
        AssignVertexInfo(positionA, normalResA, typeA, (order.x + k), vertexStartIndex);
        AssignVertexInfo(positionB, normalResB, typeB, (order.y + k), vertexStartIndex);
        AssignVertexInfo(positionC, normalResC, typeC, (order.z + k), vertexStartIndex);
    }
}

        