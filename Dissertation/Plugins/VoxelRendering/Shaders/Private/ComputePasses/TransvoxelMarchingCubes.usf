#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "/Engine/Public/Platform.ush"

float3 leafPosition;
int leafDepth;
int nodeIndex;

Buffer<float> isoValues; // 8 isoValues 
Buffer<int> typeValues; // 8 typesValues

Buffer<float> isoAdjValuesA; // 8 isoValues 
Buffer<float> isoAdjValuesB; // 8 isoValues 
Buffer<float> isoAdjValuesC; // 8 isoValues 
Buffer<float> isoAdjValuesD; // 8 isoValues 

Buffer<int> typeAdjValuesA; // 8 typesValues
Buffer<int> typeAdjValuesB; // 8 typesValues
Buffer<int> typeAdjValuesC; // 8 typesValues
Buffer<int> typeAdjValuesD; // 8 typesValues

Buffer<int> transitionLookup;
Buffer<int> flatTransitionVertexData;

RWBuffer<float> outVertexInfo;
RWBuffer<float> outNormalInfo;
RWBuffer<int> outTypeInfo;

int voxelsPerAxis;
float baseDepthScale;
float isoLevel;
int3 direction;
int transitionCellIndex;
int resetNode;

static const int transitionCornerIndexAFromEdge[13] = { 3, 2, 2, 1, 4, 8, 1, 8, 8, 3, 2, 1, 8 };
static const int transitionCornerIndexBFromEdge[13] = { 0, 1, 0, 2, 0, 2, 0, 1, 0, 7, 7, 7, 7 };
static const int transitionLengths[512] = { 0, 6, 3, 9, 6, 12, 9, 9, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 9, 15, 12, 12, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 12, 18, 15, 15, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 18, 21, 15, 15, 21, 18, 24, 15, 15, 18, 12, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 21, 21, 9, 15, 12, 18, 15, 15, 18, 12, 12, 18, 15, 21, 12, 12, 15, 9, 3, 9, 6, 12, 9, 15, 12, 12, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 12, 18, 15, 15, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 15, 21, 18, 18, 9, 9, 12, 12, 15, 15, 18, 12, 12, 12, 15, 15, 18, 18, 21, 15, 15, 15, 18, 18, 21, 15, 24, 12, 18, 18, 21, 21, 18, 12, 21, 9, 12, 12, 15, 15, 18, 18, 21, 15, 15, 15, 18, 18, 21, 21, 24, 18, 12, 12, 15, 15, 18, 12, 21, 9, 15, 15, 18, 18, 15, 9, 18, 6, 6, 12, 9, 15, 12, 18, 15, 15, 9, 15, 12, 18, 15, 21, 12, 12, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 15, 21, 12, 12, 9, 15, 12, 18, 15, 21, 18, 18, 12, 18, 15, 21, 18, 24, 15, 15, 15, 21, 18, 24, 21, 27, 12, 12, 12, 18, 15, 21, 12, 18, 9, 9, 12, 18, 15, 21, 18, 24, 21, 21, 15, 21, 18, 24, 21, 27, 18, 18, 18, 24, 21, 27, 24, 36, 27, 21, 21, 27, 24, 18, 21, 21, 18, 12, 15, 21, 18, 12, 21, 27, 24, 12, 18, 24, 21, 15, 24, 18, 21, 9, 15, 21, 18, 12, 21, 21, 12, 6, 12, 18, 15, 9, 12, 12, 9, 3, 9, 15, 12, 12, 15, 21, 18, 12, 12, 18, 15, 15, 18, 12, 15, 9, 15, 21, 18, 18, 21, 27, 24, 18, 18, 24, 21, 21, 18, 12, 15, 9, 12, 18, 15, 15, 18, 24, 21, 15, 15, 21, 18, 18, 21, 15, 18, 12, 18, 24, 21, 21, 24, 18, 15, 9, 15, 21, 18, 18, 15, 9, 12, 6, 15, 15, 18, 12, 21, 21, 24, 12, 18, 18, 21, 15, 24, 12, 21, 9, 21, 21, 24, 18, 27, 21, 18, 12, 12, 12, 15, 9, 12, 6, 9, 3, 12, 12, 15, 9, 18, 18, 21, 9, 15, 15, 18, 12, 21, 9, 18, 6, 12, 12, 15, 9, 18, 12, 9, 3, 9, 9, 12, 6, 9, 3, 6, 0 };
static const int transitionOffsets[512] = { 0, 0, 6, 9, 18, 24, 36, 45, 54, 57, 66, 72, 84, 93, 108, 120, 132, 138, 150, 159, 174, 186, 204, 219, 234, 243, 258, 270, 288, 297, 312, 324, 336, 339, 348, 354, 366, 375, 390, 402, 414, 420, 432, 441, 456, 468, 486, 501, 516, 525, 540, 552, 570, 585, 606, 624, 642, 654, 672, 687, 708, 720, 738, 753, 768, 774, 786, 795, 810, 822, 840, 855, 870, 879, 894, 906, 924, 939, 960, 978, 996, 1008, 1026, 1041, 1062, 1080, 1098, 1119, 1134, 1149, 1170, 1188, 1212, 1227, 1242, 1260, 1272, 1281, 1296, 1308, 1326, 1341, 1362, 1380, 1398, 1410, 1428, 1443, 1464, 1482, 1506, 1527, 1548, 1557, 1572, 1584, 1602, 1617, 1632, 1650, 1662, 1674, 1692, 1707, 1728, 1740, 1752, 1767, 1776, 1779, 1788, 1794, 1806, 1815, 1830, 1842, 1854, 1860, 1872, 1881, 1896, 1908, 1926, 1941, 1956, 1965, 1980, 1992, 2010, 2025, 2046, 2064, 2082, 2094, 2112, 2127, 2148, 2160, 2178, 2193, 2208, 2214, 2226, 2235, 2250, 2262, 2280, 2295, 2310, 2319, 2334, 2346, 2364, 2379, 2400, 2418, 2436, 2448, 2466, 2481, 2502, 2520, 2544, 2565, 2586, 2601, 2622, 2640, 2664, 2679, 2700, 2718, 2736, 2745, 2754, 2766, 2778, 2793, 2808, 2826, 2838, 2850, 2862, 2877, 2892, 2910, 2928, 2949, 2964, 2979, 2994, 3012, 3030, 3051, 3066, 3090, 3102, 3120, 3138, 3159, 3180, 3198, 3210, 3231, 3240, 3252, 3264, 3279, 3294, 3312, 3330, 3351, 3366, 3381, 3396, 3414, 3432, 3453, 3474, 3498, 3516, 3528, 3540, 3555, 3570, 3588, 3600, 3621, 3630, 3645, 3660, 3678, 3696, 3711, 3720, 3738, 3744, 3750, 3762, 3771, 3786, 3798, 3816, 3831, 3846, 3855, 3870, 3882, 3900, 3915, 3936, 3948, 3960, 3972, 3990, 4005, 4026, 4044, 4068, 4089, 4110, 4125, 4146, 4164, 4188, 4203, 4224, 4236, 4248, 4257, 4272, 4284, 4302, 4317, 4338, 4356, 4374, 4386, 4404, 4419, 4440, 4458, 4482, 4497, 4512, 4527, 4548, 4566, 4590, 4611, 4638, 4650, 4662, 4674, 4692, 4707, 4728, 4740, 4758, 4767, 4776, 4788, 4806, 4821, 4842, 4860, 4884, 4905, 4926, 4941, 4962, 4980, 5004, 5025, 5052, 5070, 5088, 5106, 5130, 5151, 5178, 5202, 5238, 5265, 5286, 5307, 5334, 5358, 5376, 5397, 5418, 5436, 5448, 5463, 5484, 5502, 5514, 5535, 5562, 5586, 5598, 5616, 5640, 5661, 5676, 5700, 5718, 5739, 5748, 5763, 5784, 5802, 5814, 5835, 5856, 5868, 5874, 5886, 5904, 5919, 5928, 5940, 5952, 5961, 5964, 5973, 5988, 6000, 6012, 6027, 6048, 6066, 6078, 6090, 6108, 6123, 6138, 6156, 6168, 6183, 6192, 6207, 6228, 6246, 6264, 6285, 6312, 6336, 6354, 6372, 6396, 6417, 6438, 6456, 6468, 6483, 6492, 6504, 6522, 6537, 6552, 6570, 6594, 6615, 6630, 6645, 6666, 6684, 6702, 6723, 6738, 6756, 6768, 6786, 6810, 6831, 6852, 6876, 6894, 6909, 6918, 6933, 6954, 6972, 6990, 7005, 7014, 7026, 7032, 7047, 7062, 7080, 7092, 7113, 7134, 7158, 7170, 7188, 7206, 7227, 7242, 7266, 7278, 7299, 7308, 7329, 7350, 7374, 7392, 7419, 7440, 7458, 7470, 7482, 7494, 7509, 7518, 7530, 7536, 7545, 7548, 7560, 7572, 7587, 7596, 7614, 7632, 7653, 7662, 7677, 7692, 7710, 7722, 7743, 7752, 7770, 7776, 7788, 7800, 7815, 7824, 7842, 7854, 7863, 7866, 7875, 7884, 7896, 7902, 7911, 7914, 7920 };
static const int3 offsets[13] = { int3(0, 0, 0), int3(1, 0, 0), int3(2, 0, 0), int3(0, 1, 0), int3(1, 1, 0), int3(2, 1, 0), int3(0, 2, 0), int3(1, 2, 0), int3(2, 2, 0), int3(0, 0, 2), int3(2, 0, 2), int3(0, 2, 2), int3(2, 2, 2)};

int GetIsoIndex(int3 coord)
{
    int maxIsoCount = (voxelsPerAxis + 1) * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    int index = coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    return max(0, min(index, maxIsoCount)); // 0-35
}

int SetAxisValue(int1 directionAxisVal, int axisModifier, int highAxis)
{
    return ((directionAxisVal.x < 0 ? highAxis : 0) + axisModifier);
}

int3 GetDirectionalIsoIndex(int2 coord, int axisModifier = 0, int highAxis = voxelsPerAxis, int directionMult = 1)
{
    int3 absDir = abs(direction);
    int mainAxis = dot(absDir, int3(0, 1, 2));

    int u = (mainAxis + 1) % 3;
    int v = (mainAxis + 2) % 3;

    int x = 0;
    int y = 0;
    int z = 0;

    if (u == 0)
        x = coord.x;
    else if (v == 0)
        x = coord.y;
    else if (mainAxis == 0)
        x = SetAxisValue(direction.x * directionMult, axisModifier, highAxis);

    if (u == 1)
        y = coord.x;
    else if (v == 1)
        y = coord.y;
    else if (mainAxis == 1)
        y = SetAxisValue(direction.y * directionMult, axisModifier, highAxis);

    if (u == 2)
        z = coord.x;
    else if (v == 2)
        z = coord.y;
    else if (mainAxis == 2)
        z = SetAxisValue(direction.z * directionMult, axisModifier, highAxis);
    return int3(x, y, z);
}

// C, D, A, B seems to be correct
float GetDensityHighY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ?
        isoAdjValuesC[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // C <<
        isoAdjValuesD[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // D
}

float GetDensityLowY(int2 transVoxelCoord)
{
    return transVoxelCoord.x < voxelsPerAxis ? 
        isoAdjValuesA[GetIsoIndex(GetDirectionalIsoIndex(transVoxelCoord, 0, voxelsPerAxis, -1))] : // A <<
        isoAdjValuesB[GetIsoIndex(GetDirectionalIsoIndex((transVoxelCoord - int2(voxelsPerAxis, 0)), 0, voxelsPerAxis, -1))]; // B
}

// presumes >= 9 coord
float GetTransvoxelLowRes(int2 voxelCoord, int offsetCoord)
{
    voxelCoord.x += (offsets[offsetCoord].x / 2); // 0 or 2 -> 1/2
    voxelCoord.y += (offsets[offsetCoord].y / 2);

    int3 pos = GetDirectionalIsoIndex(voxelCoord, 0, voxelsPerAxis, 1);
    return isoValues[GetIsoIndex(pos)]; 
}

// presumes < 9 coord
float GetTransvoxelHighRes(int2 voxelCoord, int offsetCoord)
{    
    voxelCoord.x = (voxelCoord.x * 2);
    voxelCoord.y = (voxelCoord.y * 2);
    
    voxelCoord.x += offsets[offsetCoord].x;
    voxelCoord.y += offsets[offsetCoord].y;

    return voxelCoord.y >= voxelsPerAxis ?
        GetDensityHighY((voxelCoord - int2(0, voxelsPerAxis))) :
        GetDensityLowY(voxelCoord);
}

float GetTransvoxelDensity(int2 voxelCoord, int offsetCoord)
{
    return (offsetCoord >= 9) ?
        GetTransvoxelLowRes(voxelCoord, offsetCoord) :
        GetTransvoxelHighRes(voxelCoord, offsetCoord);
}

// Needs refactor
int GetType(int3 coord)
{
    // This is a transvoxel coordinate in 3d- workings below are not accurate
    bool isEdge = any(coord < 0) || any(coord > voxelsPerAxis);
    return isEdge ? 0 : typeValues[(GetIsoIndex(coord))];
}

float3 ZeroAxisInDirection(float3 position)
{
    int3 zeroAxis = GetDirectionalIsoIndex(int2(1, 1), 0, 0);
    float3 zeroFAxis = float3(zeroAxis.x, zeroAxis.y, zeroAxis.z);
    position *= zeroFAxis;
    return position;
}

float3 InterpolateVertice(uint edgeCode, int k, int2 transVoxelCoord, float isoDetailScale, float isoScale, float3 worldPos, float _trCellValues[13])
{
    uint a = (edgeCode >> 4) & 0x0F;
    uint b = edgeCode & 0x0F;
    
    float densityA = _trCellValues[a];
    float densityB = _trCellValues[b];
    
    int2 positionA = int2(offsets[a].x + (transVoxelCoord.x * 2), offsets[a].y + (transVoxelCoord.y * 2));
    int2 positionB = int2(offsets[b].x + (transVoxelCoord.x * 2), offsets[b].y + (transVoxelCoord.y * 2));

    int3 positionAxisAlignedA = GetDirectionalIsoIndex(positionA, 0, (voxelsPerAxis * 2));
    int3 positionAxisAlignedB = GetDirectionalIsoIndex(positionB, 0, (voxelsPerAxis * 2));
        
    float3 pa = worldPos + (float3(positionAxisAlignedA.x, positionAxisAlignedA.y, positionAxisAlignedA.z) * isoDetailScale);
    float3 pb = worldPos + (float3(positionAxisAlignedB.x, positionAxisAlignedB.y, positionAxisAlignedB.z) * isoDetailScale);
    float3 position = pa;
    
    float denom = densityB - densityA;
    float t = abs(denom) < 0.01? 
    (densityA > isoLevel ? -0.5 : 0.5)
    : (isoLevel - densityA) / denom;
    
    t = clamp(t, -1.0, 1.0);
    position = lerp(pa, pb, t); //pa + t * (pb - pa);
    return position;
}

bool DebugTriangleOnCondition(uint edgeCode, int k, int vertexFloatIndex, int vertexStartIndex, float isoScale, float3 worldPos, int2 voxelCoords, int offset)
{
    uint a = (edgeCode >> 4) & 0x0F;
    uint b = edgeCode & 0x0F;
        
    if (a > 12 || b > 12)
    {
        float2 A = float2(0.0, 1.0);
        float2 B = float2(1.0, 1.0);
        float2 C = float2(0.0, 0.0);
        float2 D = float2(1.0, 0.0);
        float x = k % 3 == 0 ? A.x : k % 3 == 1 ? B.x : C.x;
        float y = k % 3 == 0 ? A.y : k % 3 == 1 ? B.y : C.y;
        
        int2 deltaCoord;
        deltaCoord.x = x + voxelCoords.x;
        deltaCoord.y = y + voxelCoords.y;
        float3 position = GetDirectionalIsoIndex(deltaCoord); // isoscale
        outVertexInfo[vertexFloatIndex] = position.x + worldPos.x;
        outVertexInfo[vertexFloatIndex + 1] = (position.y * 300) + worldPos.y;
        outVertexInfo[vertexFloatIndex + 2] = position.z + worldPos.z;
        outTypeInfo[vertexStartIndex + k] = 1;
        return true;
    }
    return false;
}

// x, y, 1
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void TransvoxelMarchingCubes(int3 id : SV_DispatchThreadID)
{
    if (any(id >= voxelsPerAxis)) return;
    
     int transitionCellMarchIndex = (id.x * voxelsPerAxis) + id.y;
    int maxedCount = (voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) * 15;
    int totalMarchCellsPerTransitionCell = voxelsPerAxis * voxelsPerAxis;
    int flatIndex = (transitionCellIndex * totalMarchCellsPerTransitionCell) + transitionCellMarchIndex;
    int vertexStartIndex = maxedCount + (flatIndex * 36);
    
    float scale = baseDepthScale / (1 << (leafDepth));
    float modScale = baseDepthScale / (1 << (leafDepth + 1));

    float centerDis = scale / 2.0;
    float isoScale = (scale / (voxelsPerAxis));
    float isoDetailScale = (modScale / (voxelsPerAxis));

    float3 minimumCornerWorldPos = leafPosition - float3(centerDis, centerDis, centerDis);
    
    for (int j = 0; j < 36; j++)
    {
        uint vertexFloatIndex = (vertexStartIndex + j) * 3;
        outVertexInfo[vertexFloatIndex] = 0.0;
        outVertexInfo[vertexFloatIndex + 1] = 0.0;
        outVertexInfo[vertexFloatIndex + 2] = 0.0;
        outTypeInfo[vertexStartIndex + j] = 0;
    }
    
    if (resetNode > 0) return;
    
    int2 transVoxelCoord = int2(id.x, id.y);
    int3 inDir = int3(direction.x, direction.y, direction.z);
    
    float _trCellValues[13];
    
    _trCellValues[1] = GetTransvoxelDensity(transVoxelCoord, 1);
    _trCellValues[3] = GetTransvoxelDensity(transVoxelCoord, 3);
    _trCellValues[4] = GetTransvoxelDensity(transVoxelCoord, 4);
    _trCellValues[5] = GetTransvoxelDensity(transVoxelCoord, 5);
    _trCellValues[7] = GetTransvoxelDensity(transVoxelCoord, 7);
    
    _trCellValues[0] = GetTransvoxelDensity(transVoxelCoord, 0);
    _trCellValues[2] = GetTransvoxelDensity(transVoxelCoord, 2);
    _trCellValues[6] = GetTransvoxelDensity(transVoxelCoord, 6);
    _trCellValues[8] = GetTransvoxelDensity(transVoxelCoord, 8);
    
    _trCellValues[9] = 0.0; //GetTransvoxelDensity(transVoxelCoord, 9); // _trCellValues[0];
    _trCellValues[10] = 0.0;  //GetTransvoxelDensity(transVoxelCoord, 10); // _trCellValues[2];
    _trCellValues[11] = 0.0;  //GetTransvoxelDensity(transVoxelCoord, 11); //_trCellValues[6];
    _trCellValues[12] = 0.0;  //GetTransvoxelDensity(transVoxelCoord, 12); //_trCellValues[8];
    
    int caseCode = (
        (_trCellValues[0] < isoLevel ? 1 : 0)
        | (_trCellValues[1] < isoLevel ? 2 : 0)
        | (_trCellValues[2] < isoLevel ? 4 : 0)
        | (_trCellValues[5] < isoLevel ? 8 : 0)
        | (_trCellValues[8] < isoLevel ? 16 : 0)
        | (_trCellValues[7] < isoLevel ? 32 : 0)
        | (_trCellValues[6] < isoLevel ? 64 : 0)
        | (_trCellValues[3] < isoLevel ? 128 : 0)
        | (_trCellValues[4] < isoLevel ? 256 : 0));
    
    int3 voxelCoord = GetDirectionalIsoIndex(transVoxelCoord);
    float3 voxelPosition = float3(voxelCoord.x, voxelCoord.y, voxelCoord.z) * isoScale;
    int offset = transitionOffsets[caseCode]; //7920 max item
    int length = transitionLengths[caseCode];    
    
    if (caseCode == 0 || caseCode == 511)
        return;
    
    for (uint k = 0; k < length; k += 3) // Up to 0-24 
    {
        uint startVertexIndex = caseCode * 12;
        uint edgeCodeA = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k]]; // [caseCode * 12 + k];
        uint edgeCodeB = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k + 1]]; // [caseCode * 12 + k + 1];
        uint edgeCodeC = flatTransitionVertexData[startVertexIndex + transitionLookup[offset + k] + 2]; // [caseCode  * 12 + k + 2];
        
        float3 positionA = InterpolateVertice(edgeCodeA, k, int2(id.x, id.y), isoDetailScale, isoScale, minimumCornerWorldPos, _trCellValues);
        float3 positionB = InterpolateVertice(edgeCodeB, k + 1, int2(id.x, id.y), isoDetailScale, isoScale, minimumCornerWorldPos,_trCellValues);
        float3 positionC = InterpolateVertice(edgeCodeC, k + 2, int2(id.x, id.y), isoDetailScale, isoScale, minimumCornerWorldPos, _trCellValues);

        uint vertexFloatIndexA = (vertexStartIndex + k) * 3;
        uint vertexFloatIndexB = (vertexStartIndex + k + 1) * 3;
        uint vertexFloatIndexC = (vertexStartIndex + k + 2) * 3;

        outVertexInfo[vertexFloatIndexA] = positionA.x;
        outVertexInfo[vertexFloatIndexA + 1] = positionA.y;
        outVertexInfo[vertexFloatIndexA + 2] = positionA.z;

        outVertexInfo[vertexFloatIndexB] = positionB.x;
        outVertexInfo[vertexFloatIndexB + 1] = positionB.y;
        outVertexInfo[vertexFloatIndexB + 2] = positionB.z;

        outVertexInfo[vertexFloatIndexC] = positionC.x;
        outVertexInfo[vertexFloatIndexC + 1] = positionC.y;
        outVertexInfo[vertexFloatIndexC + 2] = positionC.z;

        outTypeInfo[vertexStartIndex + k] = 0;
    }
}

        