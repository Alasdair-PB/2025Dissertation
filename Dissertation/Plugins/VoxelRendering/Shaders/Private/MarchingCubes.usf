#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"

float3 leafPosition;
uint leafDepth;
uint nodeIndex;
StructuredBuffer<float> isoValues[8];

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
uint voxelsPerNode;
float baseDepthScale;
float isoLevel;

float3 calculateNormal(int index)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);
    float density = isoValues[index];
    
    float densityXPlus = isoValues[index + offsetX.x];
    float densityXMinus = isoValues[index - offsetX.x];
    float densityYPlus = isoValues[index + offsetY.y * voxelsPerNode];
    float densityYMinus = isoValues[index - offsetY.y * voxelsPerNode];
    float densityZPlus = isoValues[index + offsetZ.z * voxelsPerNode * voxelsPerNode];
    float densityZMinus = isoValues[index - offsetZ.z * voxelsPerNode * voxelsPerNode];

    float dx = densityXPlus - densityXMinus;
    float dy = densityYPlus - densityYMinus;
    float dz = densityZPlus - densityZMinus;

    float3 normal = float3(dx, dy, dz);
    return normalize(normal);
}

float3 indexToWorld(int index, float scale)
{
    int x = index % voxelsPerNode;
    int y = (index / voxelsPerNode) % voxelsPerNode;
    int z = index / (voxelsPerNode * voxelsPerNode);
    return leafPosition + float3(x, y, z) * scale;
}
 
int createVertex(int indexA, int indexB, int vertexStartIndex, float scale)
{
    float3 posA = indexToWorld(indexA, scale);
    float3 posB = indexToWorld(indexB, scale);
    float densityA = isoValues[indexA];
    float densityB = isoValues[indexB];

    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = calculateNormal(indexA);
    float3 normalB = calculateNormal(indexB);
    float3 normal = normalize(normalA + t * (normalB - normalA));
    
    outNormals[vertexStartIndex] = normal;
    outVertices[vertexStartIndex] = position;
    return vertexStartIndex++;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    int numCubesPerAxis = voxelsPerNode - 1;
    if (id.x >= numCubesPerAxis || id.y >= numCubesPerAxis || id.z >= numCubesPerAxis) { return; }
    
    int voxelIndex = id.z * voxelsPerNode * voxelsPerNode + id.y * voxelsPerNode + id.x; // Where a voxel is 4 corners/ isoValues 
    int triangleStartIndex = nodeIndex * voxelIndex * 5;
    int vertexStartIndex = nodeIndex * voxelIndex * 15; // Given no connecting vertexes between marched cubes (will be investigated later)
    float scale = baseDepthScale / (2 + (leafDepth * 2.0));
        
    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[voxelIndex + h] < isoLevel)
            config |= (1 << h);
    }

    int edgeIndices[] = triangulation[config];
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        int vertexA = createVertex(a0, a1, vertexStartIndex, scale);
        int vertexB = createVertex(b0, b1, vertexStartIndex, scale);
        int vertexC = createVertex(c0, c1, vertexStartIndex, scale);
        
        int baseIndex = vertexStartIndex - 3;
        outTris[triangleStartIndex] = baseIndex + 2;
        outTris[triangleStartIndex + 1] = baseIndex + 1;
        outTris[triangleStartIndex + 2] = baseIndex + 0;

        triangleStartIndex += 3;
    }
}
