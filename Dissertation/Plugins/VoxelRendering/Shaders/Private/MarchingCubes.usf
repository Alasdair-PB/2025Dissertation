#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);
int leafDepth = 0;
int nodeIndex = 0;
Buffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<float3> outNormals;
RWStructuredBuffer<int> outTris;

// Constants
int voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

int GetIsoIndex(int3 coord)
{
    return coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
}

float GetDensity(int3 coord)
{
    return isoValues[GetIsoIndex(coord)];
}

float3 CalculateNormal(int3 coord)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);

    float dx = GetDensity(coord + offsetX) - GetDensity(coord - offsetX);
    float dy = GetDensity(coord + offsetY) - GetDensity(coord - offsetY);
    float dz = GetDensity(coord + offsetZ) - GetDensity(coord - offsetZ);

    return normalize(float3(dx, dy, dz));
}

void CreateVertex(int3 cornerPosA, int3 cornerPosB, int vertexIndex, float3 worldPos, float scale)
{
    float voxelScale = 4;
    float3 posA = worldPos + (cornerPosA * voxelScale); // 1 => scale
    float3 posB = worldPos + (cornerPosB * voxelScale);
    
    float densityA = GetDensity(cornerPosA);
    float densityB = GetDensity(cornerPosB);
    
    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = CalculateNormal(cornerPosA);
    float3 normalB = CalculateNormal(cornerPosB);
    float3 normal = normalize(normalA + t * (normalB - normalA));

    outNormals[vertexIndex] = normal;
    outVertices[vertexIndex] = position; 
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x > voxelsPerAxis || id.y > voxelsPerAxis || id.z > voxelsPerAxis) { return; }
    
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
    
    int triangleStartIndex = (globalVoxelIndex * 15) + (localVoxelIndex * 15);
    int vertexStartIndex = (globalVoxelIndex * 15) + (localVoxelIndex * 15);
        
    float scale = baseDepthScale / (1 + leafDepth);
    float3 worldPos = leafPosition + (id * scale);

    int3 cornerCoords[8];
    cornerCoords[0] = id + int3(0, 0, 0);
    cornerCoords[1] = id + int3(1, 0, 0);
    cornerCoords[2] = id + int3(1, 0, 1);
    cornerCoords[3] = id + int3(0, 0, 1);
    cornerCoords[4] = id + int3(0, 1, 0);
    cornerCoords[5] = id + int3(1, 1, 0);
    cornerCoords[6] = id + int3(1, 1, 1);
    cornerCoords[7] = id + int3(0, 1, 1);
    
    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[GetIsoIndex(cornerCoords[h])] < isoLevel) { config |= (1 << h); }
    }
    
    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int k = 0; k < 16; k += 3)
    {
        if (edgeIndices[k] == -1) { break; }
        
        int edgeIndexA = edgeIndices[k];
        int a0 = cornerIndexAFromEdge[edgeIndexA];
        int a1 = cornerIndexBFromEdge[edgeIndexA];

        int edgeIndexB = edgeIndices[k + 1];
        int b0 = cornerIndexAFromEdge[edgeIndexB];
        int b1 = cornerIndexBFromEdge[edgeIndexB];

        int edgeIndexC = edgeIndices[k + 2];
        int c0 = cornerIndexAFromEdge[edgeIndexC];
        int c1 = cornerIndexBFromEdge[edgeIndexC];
        
        int indexA = (vertexStartIndex + k);
        int indexB = (vertexStartIndex + k + 1);
        int indexC = (vertexStartIndex + k + 2);

        CreateVertex(cornerCoords[a0], cornerCoords[a1], indexA, worldPos, scale);
        CreateVertex(cornerCoords[b0], cornerCoords[b1], indexB, worldPos, scale);
        CreateVertex(cornerCoords[c0], cornerCoords[c1], indexC, worldPos, scale);
        
        outTris[triangleStartIndex] = indexC;
        outTris[triangleStartIndex + 1] = indexB;
        outTris[triangleStartIndex + 2] = indexA;
    }
}
