#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);
int leafDepth = 0;
int nodeIndex = 0;
Buffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
int voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

int GetIsoIndex(int3 coord)
{
    return coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
}

float3 calculateNormal(int3 coord)
{
    float dx = isoValues[GetIsoIndex(coord + int3(1, 0, 0))] - isoValues[GetIsoIndex(coord - int3(1, 0, 0))];
    float dy = isoValues[GetIsoIndex(coord + int3(0, 1, 0))] - isoValues[GetIsoIndex(coord - int3(0, 1, 0))];
    float dz = isoValues[GetIsoIndex(coord + int3(0, 0, 1))] - isoValues[GetIsoIndex(coord - int3(0, 0, 1))];
    return normalize(float3(dx, dy, dz));
}

void createVertex(int indexA, int indexB, int3 cornerPosA, int3 cornerPosB, int vertexIndex, float3 worldPos, int voxelIndex)
{
    float3 posA = worldPos + cornerPosA; // float3 posA = worldPos + (cornerPosA * scale);

    float3 posB = worldPos + cornerPosB;
    float densityA = isoValues[GetIsoIndex(cornerPosA)];
    float densityB = isoValues[GetIsoIndex(cornerPosB)];
    
    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = calculateNormal(cornerPosA);
    float3 normalB = calculateNormal(cornerPosB);
    float3 normal = normalize(normalA + t * (normalB - normalA));

    outNormals[vertexIndex] = normal;
    outVertices[vertexIndex] = position; 
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x > voxelsPerAxis || id.y > voxelsPerAxis || id.z > voxelsPerAxis) { return; }
    
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
    int triangleStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);
    int vertexStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);
    int vertexCounter = vertexStartIndex;
    
    float scale = baseDepthScale / (1 + leafDepth);
    float3 worldPos = leafPosition + (id * scale);
    
    int3 cornerCoords[8];
    cornerCoords[0] = int3(0, 0, 0);
    cornerCoords[1] = int3(1, 0, 0);
    cornerCoords[2] = int3(1, 0, 1);
    cornerCoords[3] = int3(0, 0, 1);
    cornerCoords[4] = int3(0, 1, 0);
    cornerCoords[5] = int3(1, 1, 0);
    cornerCoords[6] = int3(1, 1, 1);
    cornerCoords[7] = int3(0, 1, 1);
    
    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[GetIsoIndex(id + cornerCoords[h])] < isoLevel)
            config |= (1 << h);
    }
    
    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int k = 0; k < 16; k += 3)
    {
       if (edgeIndices[k] == -1 || edgeIndices[k + 1] == -1 || edgeIndices[k + 2] == -1)
            break;
        
        int edgeIndexA = edgeIndices[k];
        int a0 = cornerIndexAFromEdge[edgeIndexA];
        int a1 = cornerIndexBFromEdge[edgeIndexA];

        int edgeIndexB = edgeIndices[k + 1];
        int b0 = cornerIndexAFromEdge[edgeIndexB];
        int b1 = cornerIndexBFromEdge[edgeIndexB];

        int edgeIndexC = edgeIndices[k + 2];
        int c0 = cornerIndexAFromEdge[edgeIndexC];
        int c1 = cornerIndexBFromEdge[edgeIndexC];
        
        int indexA = (vertexStartIndex + k);
        int indexB = (vertexStartIndex + k + 1);
        int indexC = (vertexStartIndex + k + 2);

        createVertex(a0, a1, id + cornerCoords[a0], id + cornerCoords[a1], indexA, worldPos, localVoxelIndex);
        createVertex(b0, b1, id + cornerCoords[b0], id + cornerCoords[b1], indexB, worldPos, localVoxelIndex);
        createVertex(c0, c1, id + cornerCoords[c0], id + cornerCoords[c1], indexC, worldPos, localVoxelIndex);
        
        outTris[triangleStartIndex] = indexC;
        outTris[triangleStartIndex + 1] = indexB;
        outTris[triangleStartIndex + 2] = indexA;
    }
}
