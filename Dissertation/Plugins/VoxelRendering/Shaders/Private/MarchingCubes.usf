#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);;
uint leafDepth = 0;
uint nodeIndex = 0;
StructuredBuffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
uint voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

float3 calculateNormal(int index)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);
    float density = isoValues[index];
    
    float densityXPlus = isoValues[index + offsetX.x];
    float densityXMinus = isoValues[index - offsetX.x];
    float densityYPlus = isoValues[index + offsetY.y * voxelsPerAxis];
    float densityYMinus = isoValues[index - offsetY.y * voxelsPerAxis];
    float densityZPlus = isoValues[index + offsetZ.z * voxelsPerAxis * voxelsPerAxis];
    float densityZMinus = isoValues[index - offsetZ.z * voxelsPerAxis * voxelsPerAxis];

    float dx = densityXPlus - densityXMinus;
    float dy = densityYPlus - densityYMinus;
    float dz = densityZPlus - densityZMinus;

    float3 normal = float3(dx, dy, dz);
    return normalize(normal);
}

float3 indexToWorld(int index, float scale)
{
    int x = index % voxelsPerAxis;
    int y = (index / voxelsPerAxis) % voxelsPerAxis;
    int z = index / (voxelsPerAxis * voxelsPerAxis);
    return leafPosition + float3(x, y, z) * scale;
}
 
void createVertex(int indexA, int indexB, inout int vertexStartIndex, float scale)
{
    float3 posA = indexToWorld(indexA, scale);
    float3 posB = indexToWorld(indexB, scale);
    float densityA = isoValues[indexA];
    float densityB = isoValues[indexB];

    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = calculateNormal(indexA);
    float3 normalB = calculateNormal(indexB);
    float3 normal = normalize(normalA + t * (normalB - normalA));
    
    outNormals[vertexStartIndex] = normal;
    outVertices[vertexStartIndex] = position;
    vertexStartIndex++;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    int numCubesPerAxis = voxelsPerAxis - 1;
    if (id.x >= numCubesPerAxis || id.y >= numCubesPerAxis || id.z >= numCubesPerAxis) { return; }
    
    int voxelIndex = voxelsPerAxis * id.z + voxelsPerAxis + id.y * voxelsPerAxis + id.x; // Where a voxel is 4 corners/ isoValues 
    int triangleStartIndex = nodeIndex * voxelIndex * 5;
    int vertexStartIndex = nodeIndex * voxelIndex * 15; // Given no connecting vertexes between marched cubes (will be investigated later)
    float scale = baseDepthScale / (2 + (leafDepth * 2.0));
    int config = 0;
    
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[voxelIndex + h] < isoLevel)
            config |= (1 << h);
    }

    //const int edgeIndices[] = triangulation[config];
    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        createVertex(a0, a1, vertexStartIndex, scale);
        createVertex(b0, b1, vertexStartIndex, scale);
        createVertex(c0, c1, vertexStartIndex, scale);
        
        int baseIndex = vertexStartIndex - 3;
        outTris[triangleStartIndex] = baseIndex + 2;
        outTris[triangleStartIndex + 1] = baseIndex + 1;
        outTris[triangleStartIndex + 2] = baseIndex + 0;
        triangleStartIndex += 3;
    }
}
