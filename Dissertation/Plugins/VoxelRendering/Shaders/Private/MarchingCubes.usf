#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"

StructuredBuffer<float3> voxelBodyCoord;
StructuredBuffer<int> scalarFieldOffset;
StructuredBuffer<int> depthLevel;
StructuredBuffer<float> scalarField;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;
float isoLevel;

const float baseScale = 1.0f;
const int baseResolution = 4;
const int voxelResolutionPerAxis = 8;
const int maxDepth = 16;
const int maxVertsPerNode = voxelResolutionPerAxis * voxelResolutionPerAxis * voxelResolutionPerAxis;
const int maxTrisPerNode = maxVertsPerNode / 2;
const int maxNodes = 1024;
const int maxVertices = maxNodes * maxVertsPerNode;
const int maxTriangles = maxNodes * maxTrisPerNode;
int vertexStartIndex = 0;
int triangleStartIndex = 0;

float sampleDensity(int index)
{
    return scalarField[index];
}

int coordToIndex(int3 coord, int resolution)
{
    return coord.x + coord.y * resolution + coord.z * resolution * resolution;
}

float3 coordToWorld(int3 coord, int level)
{
    float voxelScale = baseScale * (1 << (maxDepth - level));
    return (float3(coord) * voxelScale);
}

float sampleDensityFromCoord(int3 coord, int3 baseCoord, int level, int offset)
{
    int3 local = coord - baseCoord;
    int resolution = baseResolution >> level;
    int index = offset + coordToIndex(local, resolution);
    return sampleDensity(index);
}

float3 calculateNormal(int3 coord, int3 baseCoord, int level, int offset)
{
    int3 x = int3(1, 0, 0);
    int3 y = int3(0, 1, 0);
    int3 z = int3(0, 0, 1);
    float dx = sampleDensityFromCoord(coord + x, baseCoord, level, offset) - sampleDensityFromCoord(coord - x, baseCoord, level, offset);
    float dy = sampleDensityFromCoord(coord + y, baseCoord, level, offset) - sampleDensityFromCoord(coord - y, baseCoord, level, offset);
    float dz = sampleDensityFromCoord(coord + z, baseCoord, level, offset) - sampleDensityFromCoord(coord - z, baseCoord, level, offset);
    return normalize(float3(dx, dy, dz));
}

float3 createVertex(int3 a, int3 b, int3 baseCoord, int level, int offset)
{
    float3 posA = coordToWorld(a, level);
    float3 posB = coordToWorld(b, level);

    float dA = sampleDensityFromCoord(a, baseCoord, level, offset);
    float dB = sampleDensityFromCoord(b, baseCoord, level, offset);
    float t = (isoLevel - dA) / max(0.0001, (dB - dA));
    float3 pos = posA + t * (posB - posA);

    float3 normA = calculateNormal(a, baseCoord, level, offset);
    float3 normB = calculateNormal(b, baseCoord, level, offset);
    float3 norm = normalize(normA + t * (normB - normA));

    outNormals[vertexStartIndex] = norm;
    outVertices[vertexStartIndex] = pos;

    vertexStartIndex++;
    return pos;
}

[numthreads(voxelResolutionPerAxis, voxelResolutionPerAxis, voxelResolutionPerAxis)]
void MarchingCubes(uint id : SV_DispatchThreadID)
{
    int voxelsPerNode = voxelResolutionPerAxis * voxelResolutionPerAxis * voxelResolutionPerAxis;
    int nodeIndex = id / voxelsPerNode;
    int voxelIndex = id % voxelsPerNode;

    int3 baseCoord = int3(voxelBodyCoord[nodeIndex]);
    int offset = scalarFieldOffset[nodeIndex];
    int level = depthLevel[nodeIndex];

    int3 local = int3(
        voxelIndex % voxelResolutionPerAxis,
        (voxelIndex / voxelResolutionPerAxis) % voxelResolutionPerAxis,
        (voxelIndex / (voxelResolutionPerAxis * voxelResolutionPerAxis))
    );

    if (any(local >= (voxelResolutionPerAxis - 1)))
        return;

    int3 coord = baseCoord + local;

    int3 corners[8] =
    {
        coord + int3(0, 0, 0),
        coord + int3(1, 0, 0),
        coord + int3(1, 0, 1),
        coord + int3(0, 0, 1),
        coord + int3(0, 1, 0),
        coord + int3(1, 1, 0),
        coord + int3(1, 1, 1),
        coord + int3(0, 1, 1)
    };

    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (sampleDensityFromCoord(corners[h], baseCoord, level, offset) < isoLevel)
            config |= (1 << h);
    }

    int edgeIndices[] = triangulation[config];
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        float3 v0 = createVertex(corners[c0], corners[c1], baseCoord, level, offset);
        float3 v1 = createVertex(corners[b0], corners[b1], baseCoord, level, offset);
        float3 v2 = createVertex(corners[a0], corners[a1], baseCoord, level, offset);

        int baseIndex = vertexStartIndex - 3;

        outTris[triangleStartIndex] = baseIndex + 2;
        outTris[triangleStartIndex + 1] = baseIndex + 1;
        outTris[triangleStartIndex + 2] = baseIndex + 0;

        triangleStartIndex += 3;
    }
}
