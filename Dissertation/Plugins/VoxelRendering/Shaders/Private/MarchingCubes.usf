#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"

StructuredBuffer<int> leafPosition;
StructuredBuffer<int> leafDepth;
StructuredBuffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

float3 voxelBodyPosition;

int nodeCount;
int voxelsPerNode;
float baseDepthScale;
float isoLevel;

float sampleDensity(int index)
{
    return scalarField[index];
}

int coordToIndex(int3 coord, int resolution)
{
    return coord.x + coord.y * resolution + coord.z * resolution * resolution;
}

float3 coordToWorld(int3 coord, int level)
{
    float voxelScale = baseScale * (1 << (maxDepth - level));
    return (float3(coord) * voxelScale);
}

float sampleDensityFromCoord(int3 coord, int3 baseCoord, int level, int offset)
{
    int3 local = coord - baseCoord;
    int resolution = baseResolution >> level;
    int index = offset + coordToIndex(local, resolution);
    return sampleDensity(index);
}

float3 calculateNormal(int3 coord, int3 baseCoord, int level, int offset)
{
    int3 x = int3(1, 0, 0);
    int3 y = int3(0, 1, 0);
    int3 z = int3(0, 0, 1);
    float dx = sampleDensityFromCoord(coord + x, baseCoord, level, offset) - sampleDensityFromCoord(coord - x, baseCoord, level, offset);
    float dy = sampleDensityFromCoord(coord + y, baseCoord, level, offset) - sampleDensityFromCoord(coord - y, baseCoord, level, offset);
    float dz = sampleDensityFromCoord(coord + z, baseCoord, level, offset) - sampleDensityFromCoord(coord - z, baseCoord, level, offset);
    return normalize(float3(dx, dy, dz));
}

float3 createVertex(int3 a, int3 b, int3 baseCoord, int level, int offset)
{
    float3 posA = coordToWorld(a, level);
    float3 posB = coordToWorld(b, level);

    float dA = sampleDensityFromCoord(a, baseCoord, level, offset);
    float dB = sampleDensityFromCoord(b, baseCoord, level, offset);
    float t = (isoLevel - dA) / max(0.0001, (dB - dA));
    float3 pos = posA + t * (posB - posA);

    float3 normA = calculateNormal(a, baseCoord, level, offset);
    float3 normB = calculateNormal(b, baseCoord, level, offset);
    float3 norm = normalize(normA + t * (normB - normA));

    outNormals[vertexStartIndex] = norm;
    outVertices[vertexStartIndex] = pos;

    vertexStartIndex++;
    return pos;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint id : SV_DispatchThreadID)
{
    int numCubesPerAxis = nodeCount - 1;
    if (id >= numCubesPerAxis) { return;}
    
    int voxelIndex = id * voxelsPerNode; // Where a voxel is 4 corners/ isoValues 
    int triangleStartIndex = voxelIndex * 5;
    int vertexStartIndex = voxelIndex * 15;
    
    float3 local = leafPosition[voxelIndex];
    float division = 2 + ((leafDepth[voxelIndex] * 2.0));
    local -= float3(baseDepthScale / division, baseDepthScale / division, baseDepthScale / division);

    int3 coord = voxelBodyPosition + local;

    float3 corners[8] =
    {
        coord + float3(0, 0, 0),
        coord + float3(1, 0, 0),
        coord + float3(1, 0, 1),
        coord + float3(0, 0, 1),
        coord + float3(0, 1, 0),
        coord + float3(1, 1, 0),
        coord + float3(1, 1, 1),
        coord + float3(0, 1, 1)
    };

    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (sampleDensityFromCoord(corners[h], basePosition, level, offset) < isoLevel)
            config |= (1 << h);
    }

    int edgeIndices[] = triangulation[config];
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        float3 v0 = createVertex(corners[c0], corners[c1], baseCoord, level, offset);
        float3 v1 = createVertex(corners[b0], corners[b1], baseCoord, level, offset);
        float3 v2 = createVertex(corners[a0], corners[a1], baseCoord, level, offset);

        int baseIndex = vertexStartIndex - 3;

        outTris[triangleStartIndex] = baseIndex + 2;
        outTris[triangleStartIndex + 1] = baseIndex + 1;
        outTris[triangleStartIndex + 2] = baseIndex + 0;

        triangleStartIndex += 3;
    }
}
