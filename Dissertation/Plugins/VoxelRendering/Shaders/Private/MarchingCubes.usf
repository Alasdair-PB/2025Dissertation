#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);
int leafDepth = 0;
int nodeIndex = 0;
Buffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
int voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

void createVertex(int indexA, int indexB, float3 cornerPosA, float3 cornerPosB, int vertexIndex, float3 worldPos, int voxelIndex)
{
    float3 posA = worldPos + cornerPosA;
    float3 posB = worldPos + cornerPosB;
    float densityA = isoValues[voxelIndex + indexA];
    float densityB = isoValues[voxelIndex + indexB];
    
    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    float3 normal = float3(1, 1, 1);

    outNormals[vertexIndex] = normal;
    outVertices[vertexIndex] = position; 
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x > voxelsPerAxis || id.y > voxelsPerAxis || id.z > voxelsPerAxis) { return; }
    
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
    int triangleStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);
    int vertexStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);
    int vertexCounter = vertexStartIndex;
    
    float scale = baseDepthScale / (1 + leafDepth);
    float cornerScale = scale / 2;
    float3 worldPos = leafPosition + (id * scale);
    
    int3 cornerCoords[8];
    cornerCoords[0] = int3(0, 0, 0);
    cornerCoords[1] = int3(1, 0, 0);
    cornerCoords[2] = int3(1, 0, 1);
    cornerCoords[3] = int3(0, 0, 1);
    cornerCoords[4] = int3(0, 1, 0);
    cornerCoords[5] = int3(1, 1, 0);
    cornerCoords[6] = int3(1, 1, 1);
    cornerCoords[7] = int3(0, 1, 1);
    
   /* cornerCoords[0] = int3(0, 0, 0) * cornerScale;
    cornerCoords[1] = int3(1, 0, 0) * cornerScale;
    cornerCoords[2] = int3(1, 0, 1) * cornerScale;
    cornerCoords[3] = int3(0, 0, 1) * cornerScale;
    cornerCoords[4] = int3(0, 1, 0) * cornerScale;
    cornerCoords[5] = int3(1, 1, 0) * cornerScale;
    cornerCoords[6] = int3(1, 1, 1) * cornerScale;
    cornerCoords[7] = int3(0, 1, 1) * cornerScale;*/
    
    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[localVoxelIndex + h] < isoLevel)
            config |= (1 << h);
    }
    
    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int k = 0; k < 16; k += 3)
    {
       if (edgeIndices[k] == -1 || edgeIndices[k + 1] == -1 || edgeIndices[k + 2] == -1)
            break;
        
        int edgeIndexA = edgeIndices[k];
        int a0 = cornerIndexAFromEdge[edgeIndexA];
        int a1 = cornerIndexBFromEdge[edgeIndexA];

        int edgeIndexB = edgeIndices[k + 1];
        int b0 = cornerIndexAFromEdge[edgeIndexB];
        int b1 = cornerIndexBFromEdge[edgeIndexB];

        int edgeIndexC = edgeIndices[k + 2];
        int c0 = cornerIndexAFromEdge[edgeIndexC];
        int c1 = cornerIndexBFromEdge[edgeIndexC];
        
        createVertex(a0, a1, cornerCoords[a0], cornerCoords[a1], (vertexStartIndex + (3 * k)), worldPos, localVoxelIndex);
        createVertex(b0, b1, cornerCoords[b0], cornerCoords[b1], (vertexStartIndex + (3 * k) + 1), worldPos, localVoxelIndex);
        createVertex(c0, c1, cornerCoords[c0], cornerCoords[c1], (vertexStartIndex + (3 * k) + 2), worldPos, localVoxelIndex);
        
        outTris[triangleStartIndex] = vertexStartIndex + (3 * k) + 2;
        outTris[triangleStartIndex + 1] = vertexStartIndex + (3 * k) + 1;
        outTris[triangleStartIndex + 2] = vertexStartIndex + (3 * k);
    }
}
