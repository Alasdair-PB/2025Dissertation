#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"

float3 leafPosition;
float3 voxelBodyPosition;
int leafDepth;
StructuredBuffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
int voxelsPerNode;
float baseDepthScale;
float isoLevel;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint id : SV_DispatchThreadID)
{
    int numCubesPerAxis = voxelsPerNode - 1;
    if (id >= numCubesPerAxis) { return;}
    
    int voxelIndex = id * voxelsPerNode; // Where a voxel is 4 corners/ isoValues 
    int triangleStartIndex = voxelIndex * 5;
    int vertexStartIndex = voxelIndex * 15;
    
    float3 local = leafPosition[voxelIndex];
    float allocation = baseDepthScale / (2 + (leafDepth * 2.0));
        
    float3 position = id + float3(voxelBodyPosition);

    float3 corners[8] =
    {
        position + float3(0, 0, 0),
        position + float3(1, 0, 0),
        position + float3(1, 0, 1),
        position + float3(0, 0, 1),
        position + float3(0, 1, 0),
        position + float3(1, 1, 0),
        position + float3(1, 1, 1),
        position + float3(0, 1, 1)
    };

    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[voxelIndex + h] < isoLevel)
            config |= (1 << h);
    }

    int edgeIndices[] = triangulation[config];
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        float3 v0 = createVertex(corners[c0], corners[c1]);
        float3 v1 = createVertex(corners[b0], corners[b1]);
        float3 v2 = createVertex(corners[a0], corners[a1]);

        int baseIndex = vertexStartIndex - 3;

        outTris[triangleStartIndex] = baseIndex + 2;
        outTris[triangleStartIndex + 1] = baseIndex + 1;
        outTris[triangleStartIndex + 2] = baseIndex + 0;

        triangleStartIndex += 3;
    }
}
