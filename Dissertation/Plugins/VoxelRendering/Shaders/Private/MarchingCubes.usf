#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);
int leafDepth = 0;
int nodeIndex = 0;
Buffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWBuffer<int> outTris;
RWStructuredBuffer<float3> outNormals;

// Constants
int voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

float3 calculateNormal(int index)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);
    //float density = isoValues[index];
    
    float densityXPlus = 1;// isoValues[index + offsetX.x];
    float densityXMinus = 1; // = isoValues[index - offsetX.x];
    float densityYPlus = 1; // = isoValues[index + offsetY.y * voxelsPerAxis];
    float densityYMinus = 1; // = isoValues[index - offsetY.y * voxelsPerAxis];
    float densityZPlus = 1; // = isoValues[index + offsetZ.z * voxelsPerAxis * voxelsPerAxis];
    float densityZMinus = 1; // = isoValues[index - offsetZ.z * voxelsPerAxis * voxelsPerAxis];

    float dx = densityXPlus - densityXMinus;
    float dy = densityYPlus - densityYMinus;
    float dz = densityZPlus - densityZMinus;

    float3 normal = float3(dx, dy, dz);
    return normalize(normal);
}

float3 indexToWorld(int index, float scale)
{
    int x = index % voxelsPerAxis;
    int y = (index / voxelsPerAxis) % voxelsPerAxis;
    int z = index / (voxelsPerAxis * voxelsPerAxis);
    return leafPosition + float3(x, y, z) * scale;
}
 
void createVertex(int indexA, int indexB, inout int vertexStartIndex, float scale, int voxelIndex)
{
    float3 posA = indexToWorld(indexA, scale);
    float3 posB = indexToWorld(indexB, scale);
    
    float densityA = isoValues[voxelIndex + indexA];
    float densityB = isoValues[voxelIndex + indexB];

    float t = (isoLevel - densityA) / (densityB - densityA);
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = calculateNormal(indexA);
    float3 normalB = calculateNormal(indexB);
    float3 normal = normalize(normalA + t * (normalB - normalA));
    
    //outNormals[vertexStartIndex] = normal; //vertexStartIndex
    //outVertices[vertexStartIndex] = position;
    vertexStartIndex++;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    if (id.x > voxelsPerAxis || id.y > voxelsPerAxis || id.z > voxelsPerAxis) { return; }
    
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
    int triangleStartIndex = (globalVoxelIndex * voxelsPerLeaf * 1) + (localVoxelIndex * 1);
    //int triangleStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);

    //outTris[triangleStartIndex] = 123; // filler values while debugging
   // outTris[triangleStartIndex + 1] = 456;
    //outTris[triangleStartIndex + 2] = 789;
    
    // outTris[0] = 6;

    outTris[triangleStartIndex] = 6;
   
    
    int vertexStartIndex = (globalVoxelIndex * voxelsPerLeaf * 15) + (localVoxelIndex * 15);

    float scale = baseDepthScale / (2 + (leafDepth * 2.0));
    int config = 0;
    
    for (int h = 0; h < 8; ++h)
    {
        if (1 < isoValues[localVoxelIndex + h])
            config |= (1 << h);
    }

    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int i = 0; i < 16; i += 3)
    {
        if (edgeIndices[i] == -1 || edgeIndices[i + 1] == -1 || edgeIndices[i + 2] == -1)
            break;

        int a0 = cornerIndexAFromEdge[edgeIndices[i]];
        int a1 = cornerIndexBFromEdge[edgeIndices[i]];

        int b0 = cornerIndexAFromEdge[edgeIndices[i + 1]];
        int b1 = cornerIndexBFromEdge[edgeIndices[i + 1]];

        int c0 = cornerIndexAFromEdge[edgeIndices[i + 2]];
        int c1 = cornerIndexBFromEdge[edgeIndices[i + 2]];

        createVertex(a0, a1, vertexStartIndex, scale, localVoxelIndex);
        createVertex(b0, b1, vertexStartIndex, scale, localVoxelIndex);
        createVertex(c0, c1, vertexStartIndex, scale, localVoxelIndex);
        
        int baseIndex = vertexStartIndex - 3;

        //outTris[triangleStartIndex] = baseIndex + 2;
        //outTris[triangleStartIndex + 1] = baseIndex + 1;
        //outTris[triangleStartIndex + 2] = baseIndex + 0;
        //triangleStartIndex += 3;
    }
}
