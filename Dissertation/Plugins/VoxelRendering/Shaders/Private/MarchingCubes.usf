#pragma once
#pragma COMPUTE_SHADER_ENTRYPOINT(MarchingCubes)
#include "MarchTables.usf"
#include "/Engine/Public/Platform.ush"

float3 leafPosition = float3(0, 0, 0);
int leafDepth = 0;
int nodeIndex = 0;
Buffer<float> isoValues;

RWStructuredBuffer<float3> outVertices;
RWStructuredBuffer<float3> outNormals;
RWStructuredBuffer<int> outTris;

int voxelsPerAxis = 0;
float baseDepthScale = 0;
float isoLevel = 0;

int GetIsoIndex(int3 coord)
{
    int maxIsoCount = (voxelsPerAxis + 1) * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    int index = coord.x + coord.y * (voxelsPerAxis + 1) + coord.z * (voxelsPerAxis + 1) * (voxelsPerAxis + 1);
    return index; // max(0, min(index, maxIsoCount));
}

float GetDensity(int3 coord)
{
    int3 safeCoord = clamp(coord, 0, voxelsPerAxis + 1);
    return isoValues[(GetIsoIndex(safeCoord))];
}

float3 CalculateNormal(int3 coord)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);

    float dx = GetDensity(coord + offsetX) - GetDensity(coord - offsetX);
    float dy = GetDensity(coord + offsetY) - GetDensity(coord - offsetY);
    float dz = GetDensity(coord + offsetZ) - GetDensity(coord - offsetZ);
    return normalize(float3(dx, dy, dz));
}

void CreateVertex(int3 cornerPosA, int3 cornerPosB, int vertexIndex, float3 worldPos, float isoScale)
{
    float3 posA = worldPos + (cornerPosA * isoScale);
    float3 posB = worldPos + (cornerPosB * isoScale);
    
    float densityA = GetDensity(cornerPosA);
    float densityB = GetDensity(cornerPosB);
    
    float denom = densityB - densityA;
    float t = abs(denom) > 0.0001f ? (isoLevel - densityA) / denom : 0.5f;
    float3 position = posA + t * (posB - posA);
    
    float3 normalA = CalculateNormal(cornerPosA);
    float3 normalB = CalculateNormal(cornerPosB);
    float3 normalRes = normalA + t * (normalB - normalA);

    outNormals[vertexIndex] = normalRes.x == 0 && normalRes.y == 0 && normalRes.z == 0 ? normalRes : float3(1, 1, 1);
    outVertices[vertexIndex] = position; 
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubes(int3 id : SV_DispatchThreadID)
{
    if (id.x > voxelsPerAxis - 1 || id.y > voxelsPerAxis - 1 || id.z > voxelsPerAxis - 1) { return; }
    
    int voxelsPerLeaf = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
    int globalVoxelIndex = nodeIndex * voxelsPerLeaf;
    int localVoxelIndex = ((id.z * (voxelsPerAxis * voxelsPerAxis)) + (id.y * voxelsPerAxis) + id.x);
    int triangleStartIndex = (globalVoxelIndex * 15) + (localVoxelIndex * 15);
    int vertexStartIndex = (globalVoxelIndex * 15) + (localVoxelIndex * 15);
    
    float scale = baseDepthScale / (pow(2, leafDepth));
    float centerDis = scale / 2;
    float isoScale = (scale / (voxelsPerAxis + 1));
    float3 initPosition = leafPosition - float3(centerDis, centerDis, centerDis);
    float3 worldPos = initPosition + (id * isoScale);

    int3 cornerCoords[8];
    cornerCoords[0] = id + int3(0, 0, 0);
    cornerCoords[1] = id + int3(1, 0, 0);
    cornerCoords[2] = id + int3(1, 0, 1);
    cornerCoords[3] = id + int3(0, 0, 1);
    cornerCoords[4] = id + int3(0, 1, 0);
    cornerCoords[5] = id + int3(1, 1, 0);
    cornerCoords[6] = id + int3(1, 1, 1);
    cornerCoords[7] = id + int3(0, 1, 1);
    
    int config = 0;
    for (int h = 0; h < 8; ++h)
    {
        if (isoValues[GetIsoIndex(cornerCoords[h])] < isoLevel)
            config |= (1 << h); 
    }
    
    const int edgeIndices[16] =
    {
        triangulation[config][0],
        triangulation[config][1],
        triangulation[config][2],
        triangulation[config][3],
        triangulation[config][4],
        triangulation[config][5],
        triangulation[config][6],
        triangulation[config][7],
        triangulation[config][8],
        triangulation[config][9],
        triangulation[config][10],
        triangulation[config][11],
        triangulation[config][12],
        triangulation[config][13],
        triangulation[config][14],
        triangulation[config][15]
    };
    
    for (int k = 0; k < 16; k += 3)
    {
        if (edgeIndices[k] == -1)
        { 
            break; 
        }
        
        int edgeIndexA = edgeIndices[k];
        int a0 = cornerIndexAFromEdge[edgeIndexA];
        int a1 = cornerIndexBFromEdge[edgeIndexA];

        int edgeIndexB = edgeIndices[k + 1];
        int b0 = cornerIndexAFromEdge[edgeIndexB];
        int b1 = cornerIndexBFromEdge[edgeIndexB];

        int edgeIndexC = edgeIndices[k + 2];
        int c0 = cornerIndexAFromEdge[edgeIndexC];
        int c1 = cornerIndexBFromEdge[edgeIndexC];
        
        int indexA = (vertexStartIndex + k);
        int indexB = (vertexStartIndex + k + 1);
        int indexC = (vertexStartIndex + k + 2);

        CreateVertex(cornerCoords[a0], cornerCoords[a1], indexA, worldPos, isoScale);
        CreateVertex(cornerCoords[b0], cornerCoords[b1], indexB, worldPos, isoScale);
        CreateVertex(cornerCoords[c0], cornerCoords[c1], indexC, worldPos, isoScale);
        
        outTris[triangleStartIndex] = indexC;
        outTris[triangleStartIndex + 1] = indexB;
        outTris[triangleStartIndex + 2] = indexA;
    }
}
