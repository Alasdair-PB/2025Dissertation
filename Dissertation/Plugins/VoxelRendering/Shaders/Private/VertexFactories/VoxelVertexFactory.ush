#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

// ************************ Required Structs for base feature support ************************
struct FVoxelVertexInfo
{
    float3 Position;
    float3 Normal;
};

StructuredBuffer<FVoxelVertexInfo> VoxelVF;

struct FVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    float3 Normal : ATTRIBUTE1;
    uint VertexId : SV_VertexID;

    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};


struct FPositionOnlyVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FPositionAndNormalOnlyVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    float3 Normal : ATTRIBUTE1;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FVertexFactoryIntermediates
{
    float3 Position;
    half3x3 TangentToLocal;
    half3x3 TangentToWorld;
    half TangentToWorldSign;
    half4 Color;
    half Alpha;
    FSceneDataIntermediates SceneData;
};

struct FVertexFactoryInterpolantsVSToPS
{
	TANGENTTOWORLD_INTERPOLATOR_BLOCK
    half4 Color : COLOR0;
    half Alpha : COLOR1;
    float2 TexCoords : TEXCOORD0;
};

// ************************ Utility Functions ************************

float3 SafeNormalize(float3 V)
{
    return V / sqrt(max(dot(V, V), 0.01));
}

float3 ApplyClipping(float3 Position)
{
    return Position;
}

float3 ProcessPosition(float3 Position, half3x3 TangentToLocal)
{
    return Position;
}

float3 ProcessPosition(float3 Position)
{
    return Position;
}

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

float2 NormalBasedPlanarMapping(FVertexFactoryInput Input, float2 UVDensity)
{
    float3 N = normalize(Input.Normal);
    float2 UV;

    if (abs(N.z) > abs(N.x) && abs(N.z) > abs(N.y))
        UV = Input.Position.xy; // XY plane
    else if (abs(N.y) > abs(N.x))
        UV = Input.Position.xz; // XZ plane
    else
        UV = Input.Position.yz; // YZ plane
    return UV * UVDensity;
}

void GetTangents(FVertexFactoryInput Input, out float4 Right, out float4 Up)
{
    float3 N = SafeNormalize(Input.Normal);
    float3 T = SafeNormalize(cross(N, float3(0, 0, 1)));
    float3 B = cross(N, T);
    Right = float4(T, 1);
    Up = float4(B, 1);
}

half3x3 CalcTangentToLocal(FVertexFactoryInput Input)
{
    float3 Normal = SafeNormalize(Input.Normal);
    float3 Tangent = SafeNormalize(cross(Normal, float3(0, 0, 1)));
    if (length(Tangent) < 0.1)
        Tangent = SafeNormalize(cross(Normal, float3(1, 0, 0)));
    float3 Binormal = cross(Normal, Tangent);
    
    return half3x3(Tangent, Binormal, Normal);
}

half3x3 CalcTangentToWorldNoScale(half3x3 TangentToLocal, half3x3 LocalToWorld)
{
    return mul(TangentToLocal, LocalToWorld);
}

float3x3 CalcTangentBasis(FVertexFactoryInput Input)
{
    float4 Right, Up;
    GetTangents(Input, Right, Up);
    return float3x3(Right.xyz, Up.xyz, -normalize(cross(Right.xyz, Up.xyz)));
}

float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

uint GetInputVertexIndex(uint TriangleIndex, int VertexIndex)
{
    return TriangleIndex * 3 + VertexIndex;
}

// ************************ Instancing, LOD, et al Support ************************
// functions expected by Unreal Engine for feature support. 

float3 VertexFactoryGetInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPreviousInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(
        ApplyClipping(Input.Position),
        GetPrimitiveDataFromUniformBuffer().LocalToWorld);

    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz);
    return WorldPosition;
}
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(
        ApplyClipping(Input.Position),
        GetPrimitiveDataFromUniformBuffer().LocalToWorld);

    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz);
    return WorldPosition;
}

float3 TransformWorldPositionToLocal(float3 InWorldPosition)
{
    return mul(float4(InWorldPosition, 1), Primitive.WorldToLocal).xyz;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(Intermediates.Position, Intermediates.SceneData.Primitive.LocalToWorld);
    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz, Intermediates.TangentToLocal);
    return WorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return VertexFactoryGetWorldPosition(Input, Intermediates);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToWorld[2];
}

float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    return RotateLocalToWorld(Input.Normal.xyz);
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint GetVertexFetchBufferOffset(uint VertexId)
{
    return VertexId;
}

float3 VoxelGetInstancePosition(uint VertexId)
{
    uint Idx = GetVertexFetchBufferOffset(VertexId);
    return VoxelVF[Idx].Position;
}

FVertexFactoryInput LoadVertexFactoryInputFromIndices(uint TriangleIndex, int VertexIndex)
{
    FVertexFactoryInput Input = (FVertexFactoryInput) 0;
    float3 Position = VoxelGetInstancePosition(VertexIndex);
        Input.Position = Position.xyz;
    Input.Normal = float3(0, 0, 1);
    Input.VertexId = GetInputVertexIndex(TriangleIndex, VertexIndex);
    return Input;
}

// ************************ Parameters & Intermediates Support ************************

FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal, bool bIsPreviousFrame = false)
{
    
    FMaterialVertexParameters Result = (FMaterialVertexParameters) 0;
    Result.WorldPosition = WorldPosition;
    Result.VertexColor = Intermediates.Color;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    return Result;
    /*
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    Result.PreSkinnedNormal = TangentToLocal[2];
    Result.PreSkinnedPosition = WorldPosition;
    Result.PositionInstanceSpace = VertexFactoryGetPreviousInstanceSpacePosition(Input, Intermediates);
    Result.PositionPrimitiveSpace = Result.PositionInstanceSpace;
    Result.LWCData = MakeMaterialLWCData(Result);
  
#if NUM_MATERIAL_TEXCOORDS_VERTEX
  for (int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordinateIndex++)
    {
        Result.TexCoords[CoordinateIndex] = float2(0,0);
    }
#endif  //NUM_MATERIAL_TEXCOORDS_VERTEX*/
    
   // return Result;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif	//NUM_MATERIAL_TEXCOORDS

    Result.TwoSidedSign = 1;
    Result.PrimitiveId = 0;
    return Result;
}

/*
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 PixelPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
	
    float3 localPosition = TransformWorldPositionToLocal(PixelPosition.xyz); //Assuming PixelPosition is in world-space
	
    Result.AbsoluteWorldPosition = PixelPosition; //TODO Is this right?
	
    float3 volumeNormal = normalize(cross(ddx(PixelPosition.xyz), ddy(PixelPosition.xyz)));
	
	// This fixes inaccuracies/rounding errors which can otherwise occur
    volumeNormal = floor(volumeNormal + float3(0.5, 0.5, 0.5));
	
    Result.WorldNormal = TransformLocalToTranslatedWorld(volumeNormal);
	
	// Because we know our normal is pointing along one of the three main axes we can trivially compute a tangent space.
    float3 volumeTangent = volumeNormal.yzx;
    float3 volumeBinormal = volumeNormal.zxy;
	
	// And from our tangent space we can now compute texture coordinates.
    float2 texCoords = float2(dot(PixelPosition.xyz, volumeTangent), dot(PixelPosition.xyz, volumeBinormal));
    texCoords = texCoords - float2(0.5, 0.5); // Required because integer positions are at the center of the voxel.

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = texCoords;
#endif
	
	//These are in volume space, should be in world space?
    Result.TangentToWorld[0] = volumeTangent;
    Result.TangentToWorld[1] = volumeBinormal;
    Result.TangentToWorld[2] = volumeNormal;
	
    Result.VertexColor = GetColor(Interpolants);

    Result.TwoSidedSign = 1;
    return Result;
}*/

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants;
    Interpolants = (FVertexFactoryInterpolantsVSToPS) 0;
    
    Interpolants.TangentToWorld0 = float4(Intermediates.TangentToWorld[0], 0);
    Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
    
    Interpolants.Color = VertexParameters.VertexColor;
    Interpolants.Alpha = Intermediates.Alpha;
    Interpolants.TexCoords = NormalBasedPlanarMapping(Input, float2(1, 1));
    return Interpolants;
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Position = Input.Position.xyz;
    Intermediates.TangentToLocal = CalcTangentToLocal(Input);
    Intermediates.TangentToWorldSign = Intermediates.SceneData.InstanceData.DeterminantSign;
    Intermediates.TangentToWorld = CalcTangentToWorldNoScale(Intermediates.TangentToLocal, (half3x3) Intermediates.SceneData.Primitive.LocalToWorld);
    Intermediates.Color = half4(1,1,1,1);
    Intermediates.Alpha = 1;

    return Intermediates;
}

// ************************ RayTrace & Compute Support ************************


#if RAYHITGROUPSHADER || COMPUTESHADER
uint GetNumRayTracingDynamicMeshVerticesIndirect()
{
	return 0;
}
#endif

#if COMPUTESHADER

FVertexFactoryInput LoadVertexFactoryInputForDynamicUpdate(uint TriangleIndex, int VertexIndex, uint PrimitiveId, uint DrawInstanceId)
{
	FVertexFactoryInput Input = LoadVertexFactoryInputFromIndices(TriangleIndex, VertexIndex);
	FPrimitiveSceneData PrimitiveData = GetPrimitiveData(PrimitiveId);
	VF_GPUSCENE_SET_INPUT_FOR_RT(Input, PrimitiveData.InstanceSceneDataOffset + DrawInstanceId, DrawInstanceId);
	return Input;
}
#endif


#include "/Engine/Private/VertexFactoryDefaultInterface.ush"
