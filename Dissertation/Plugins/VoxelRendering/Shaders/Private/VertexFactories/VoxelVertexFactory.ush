#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

// ************************ Required Structs for base feature support ************************
Buffer<float> VoxelVF;
Buffer<float> VoxelNormalVF;

struct FVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    float3 Normal : ATTRIBUTE1;
    uint VertexId : SV_VertexID;

    VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FPositionOnlyVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FPositionAndNormalOnlyVertexFactoryInput
{
    float3 Position : ATTRIBUTE0;
    float3 Normal : ATTRIBUTE1;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FVertexFactoryIntermediates
{
    half3x3 TangentToLocal;
    half3x3 TangentToWorld;
    half TangentToWorldSign;
    half4 Color;
    half Alpha;
    float3 Position;
    float3 Normal;
    FSceneDataIntermediates SceneData;
};

struct FVertexFactoryInterpolantsVSToPS
{
	TANGENTTOWORLD_INTERPOLATOR_BLOCK
    half4 Color : COLOR0;
    half Alpha : COLOR1;
    float2 TexCoords : TEXCOORD0;
};

// ************************ Utility Functions ************************
float3 SafeNormalize(float3 Vec)
{
    float L = length(Vec);
    if (L > 1.0e-6)
    {
        return Vec / L;
    }
    return float3(1, 0, 0);
}

float3 ApplyClipping(float3 Position)
{
    return Position;
}

float3 ProcessPosition(float3 Position, half3x3 TangentToLocal)
{
    return Position;
}

float3 ProcessPosition(float3 Position)
{
    return Position;
}

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

half3x3 CalcTangentToWorldNoScale(in half3x3 TangentToLocal)
{
    half3x3 LocalToWorld = GetLocalToWorld3x3();
    half3 InvScale = Primitive.InvNonUniformScale;
    LocalToWorld[0] *= InvScale.x;
    LocalToWorld[1] *= InvScale.y;
    LocalToWorld[2] *= InvScale.z;
    return mul(TangentToLocal, LocalToWorld);
}

float4 TransformTranslatedWorldToLocal(float4 TranslatedWorldPosition, FDFInverseMatrix WorldToLocal)
{
    float4x4 TranslatedWorldToLocal = DFFastToTranslatedWorld(WorldToLocal, ResolvedView.PreViewTranslation);
    float4 LocalPosition = mul(TranslatedWorldPosition, TranslatedWorldToLocal);
    return LocalPosition;
}

void GetTangents(FVertexFactoryInput Input, out float4 Right, out float4 Up)
{
    float3 N = SafeNormalize(Input.Normal);
    float3 T = abs(N.z) < 0.999 ? normalize(cross(float3(0, 0, 1), N)) : float3(1, 0, 0);
    float3 B = normalize(cross(N, T));
    Right = float4(T, 1.0);
    Up = float4(B, 1.0);
}

// ************************ Instancing, LOD, et al Support ************************
// functions expected by Unreal Engine for feature support. 

float3 VertexFactoryGetInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPreviousInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    FDFMatrix LocalToWorld = Intermediates.SceneData.Primitive.LocalToWorld;
    float3 Position = Intermediates.Position;
    float4 WorldPosition = TransformLocalToTranslatedWorld(Position, LocalToWorld);
    return WorldPosition;
}

float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    FDFMatrix Transform = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    float4 WorldPosition = TransformLocalToTranslatedWorld(ApplyClipping(Input.Position), Transform);
    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz);
    return WorldPosition;
}

float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    FDFMatrix Transform = GetPrimitiveDataFromUniformBuffer().LocalToWorld;
    float4 WorldPosition = TransformLocalToTranslatedWorld(ApplyClipping(Input.Position), Transform);
    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz);
    return WorldPosition;
}

float3 TransformWorldPositionToLocal(float3 InWorldPosition)
{
    return (mul(float4(InWorldPosition, 1.0), Primitive.WorldToLocal)).xyz;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return mul(float4(Intermediates.Position, 1.0), DFMultiplyTranslationDemote(Intermediates.SceneData.InstanceData.PrevLocalToWorld, ResolvedView.PrevPreViewTranslation));
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return (float3) Intermediates.TangentToWorld[2];
}


float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    return (float3) RotateLocalToWorld(Input.Normal.xyz);
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return uint(0);
}

uint GetVertexFetchBufferOffset(uint VertexId)
{
    return VertexId * 3;
}

float3 VoxelGetInstancePosition(uint VertexId)
{
    return float3(VoxelVF[VertexId], VoxelVF[VertexId + 1], VoxelVF[VertexId + 2]);
}

float3 VoxelGetInstanceNormal(uint VertexId)
{
    return float3(VoxelNormalVF[VertexId], VoxelNormalVF[VertexId + 1], VoxelNormalVF[VertexId + 2]);
}

FVertexFactoryInput LoadVertexFactoryInputFromIndices(uint TriangleIndex, int VertexIndex)
{
    FVertexFactoryInput Input;
    
    Input.VertexId = TriangleIndex * 3 + VertexIndex;
    uint VertexOffset = GetVertexFetchBufferOffset(Input.VertexId);
    float3 Position = VoxelGetInstancePosition(VertexOffset);
    float3 normal = VoxelGetInstanceNormal(VertexOffset);

    Input.Position = Position.xyz;
    Input.Normal = normalize(normal.xyz);
    return Input;
}

// ************************ Parameters & Intermediates Support ************************
half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
}

FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal, bool bIsPreviousFrame = false)
{
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.VertexColor = Intermediates.Color;
    Result.PositionPrimitiveSpace = Result.PositionInstanceSpace; 
    Result.TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3());
    Result.PreSkinnedPosition = WorldPosition;
    Result.PreSkinnedNormal = Intermediates.Normal; //TangentToLocal[2];

    if (bIsPreviousFrame)
    {
        Result.PositionInstanceSpace = VertexFactoryGetPreviousInstanceSpacePosition(Input, Intermediates);
    }
    else
    {
        Result.PositionInstanceSpace = VertexFactoryGetInstanceSpacePosition(Input, Intermediates);
    }
    
    Result.PositionPrimitiveSpace = Result.PositionInstanceSpace;
    Result.LWCData = MakeMaterialLWCData(Result);
    return Result;
}

uint GetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();
    
    Result.Particle.Color = half4(1, 1, 1, 1);
    Result.TwoSidedSign = 0;
    Result.VertexColor = Interpolants.Color;
    Result.VertexColor.a = saturate((lerp(1, 1 - distance(Interpolants.TexCoords, 0.5), Interpolants.Color.a) - 0.5) * 10000) * Interpolants.Alpha;
    Result.PrimitiveId = GetPrimitiveId(Interpolants);

    #if NUM_TEX_COORD_INTERPOLATORS
        Result.TexCoords[0] = Interpolants.TexCoords;
    #endif
    return Result;
}

float2 NormalBasedPlanarMapping(FVertexFactoryInput Input, float2 UVDensity)
{
    float3 N = normalize(Input.Normal);
    float2 UV = float2(0.0, 0.0);
    if (abs(N.z) > abs(N.x) && abs(N.z) > abs(N.y))
        UV = Input.Position.xy; // XY plane
    else if (abs(N.y) > abs(N.x))
        UV = Input.Position.xz; // XZ plane
    else
        UV = Input.Position.yz; // YZ plane
    return UV * UVDensity;
}

float3x3 CalcTangentBasis(FVertexFactoryInput Input)
{
    float4 Right, Up;
    GetTangents(Input, Right, Up);
    return float3x3(
			Right.xyz,
			Up.xyz,
			-normalize(cross(Right.xyz, Up.xyz))
			);
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants;
    Interpolants.TangentToWorld0.xyz = Intermediates.TangentToWorld[0];
    Interpolants.TangentToWorld0.w = 0.0;    
    Interpolants.TangentToWorld2 = float4((float3)Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
    
    Interpolants.Color = Intermediates.Color;
    Interpolants.Alpha = Intermediates.Alpha;
    Interpolants.TexCoords = NormalBasedPlanarMapping(Input, float2(1.0, 1.0));
    return Interpolants;
}


half3x3 CalcTangentToLocal(FVertexFactoryInput Input)
{
    half3x3 TangentToLocal;
    float3 Normal = SafeNormalize(Input.Normal);
    float3 WorldUpWS = float3(0.0, 0.0, 1.0);
    float3x3 WorldToLocal = GetLocalToWorld3x3();
    float3x3 LocalToWorld = WorldToLocal;
    float3x3 InverseLocalToWorld = transpose(LocalToWorld);
    float3 WorldUpLS = mul(WorldUpWS, InverseLocalToWorld);
    float3 Tangent = SafeNormalize(cross(Normal, WorldUpLS));
    
    if (length(Tangent) < 0.1)
        Tangent = SafeNormalize(cross(Normal, float3(1.0, 0.0, 0.0)));

    float3 Binormal = cross(Normal, Tangent);
    TangentToLocal[0] = half3(Tangent);
    TangentToLocal[1] = half3(Binormal);
    TangentToLocal[2] = half3(Normal);
    return TangentToLocal;
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Position = Input.Position.xyz;
    Intermediates.TangentToLocal = CalcTangentToLocal(Input);
    Intermediates.TangentToWorldSign = 1;
    Intermediates.TangentToWorld = (half3x3) CalcTangentToWorldNoScale((float3x3) Intermediates.TangentToLocal);
    
    int typeValue = 0.0;
    half4 vertexColourOut = half4(typeValue, 0.0, 0.0, 1.0);
    Intermediates.Color = vertexColourOut;
    Intermediates.Alpha = half(1.0);
    Intermediates.Normal = Input.Normal.xyz;
    return Intermediates;
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    FPrimitiveSceneData PrimitiveData = GetPrimitiveDataFromUniformBuffer();
    return float4(DFFastToTranslatedWorld(PrimitiveData.ObjectWorldPosition, ResolvedView.PreViewTranslation), PrimitiveData.ObjectRadius);
}

#if USE_INSTANCING
float4 VertexFactoryGetInstanceHitProxyId(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates) { return float4(0.0,0.0,0.0,0.0); }
#endif


float4 VertexFactoryGetPositionForShadowDepth(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return TransformLocalToTranslatedWorld(Intermediates.Position, Intermediates.SceneData.Primitive.LocalToWorld);
}

// ************************ RayTrace & Compute Support ************************

#if RAYHITGROUPSHADER || COMPUTESHADER
uint GetNumRayTracingDynamicMeshVerticesIndirect()
{
	return uint(0);
}
#endif


#if RAYHITGROUPSHADER
FVertexFactoryInput LoadVertexFactoryInputForHGS(uint TriangleIndex, int VertexIndex)
{
	FVertexFactoryInput Input = LoadVertexFactoryInputFromIndices(TriangleIndex, VertexIndex);
		
#if VF_USE_PRIMITIVE_SCENE_DATA
	VF_GPUSCENE_SET_INPUT_FOR_RT(Input, GetInstanceUserData(), 0U);
#endif
		
	return Input;
}
#endif

#if COMPUTESHADER

FVertexFactoryInput LoadVertexFactoryInputForDynamicUpdate(uint TriangleIndex, int VertexIndex, uint PrimitiveId, uint DrawInstanceId)
{
	FVertexFactoryInput Input = LoadVertexFactoryInputFromIndices(TriangleIndex, VertexIndex);
	FPrimitiveSceneData PrimitiveData = GetPrimitiveData(PrimitiveId);
	VF_GPUSCENE_SET_INPUT_FOR_RT(Input, PrimitiveData.InstanceSceneDataOffset + DrawInstanceId, DrawInstanceId);
	return Input;
}
#endif

#include "/Engine/Private/VertexFactoryDefaultInterface.ush"
