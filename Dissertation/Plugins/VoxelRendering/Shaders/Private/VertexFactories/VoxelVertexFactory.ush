#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

static float2 PrecomputedUV_Quad[8] = { float2(-0.5, -0.5), float2(0.5, -0.5), float2(0.5, 0.5), float2(-0.5, 0.5), float2(0, 1), float2(1, 1), float2(1, 0), float2(0, 0) };

// ************************ Required Structs for base feature support ************************

struct FVertexFactoryInput
{
    float4 Position : POSITION;
    half4 Color : ATTRIBUTE1;
    float3 Normal : NORMAL;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FPositionOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FPositionAndNormalOnlyVertexFactoryInput
{
    float4 Position : ATTRIBUTE0;
    float3 Normal : ATTRIBUTE1;
    uint VertexId : SV_VertexID;

	VF_INSTANCED_STEREO_DECLARE_INPUT_BLOCK()
};

struct FVertexFactoryIntermediates
{
    float3 Position;
    half3x3 TangentToLocal;
    half3x3 TangentToWorld;
    half TangentToWorldSign;
    half4 Color;
    half Alpha;
    FSceneDataIntermediates SceneData;
};

struct FVertexFactoryInterpolantsVSToPS
{
	TANGENTTOWORLD_INTERPOLATOR_BLOCK
    half4 Color : COLOR0;
    half Alpha : COLOR1;
    float2 TexCoords : TEXCOORD0;
};

// ************************ Utility Functions ************************

float3 SafeNormalize(float3 V)
{
    return V / sqrt(max(dot(V, V), 0.01));
}

float3 VoxelGetInstancePosition(uint VertexId)
{
    uint Idx = (VertexId / 4) * 5; 
    return float3(VoxelVF.VertexFetch_Buffer[Idx], VoxelVF.VertexFetch_Buffer[Idx + 1], VoxelVF.VertexFetch_Buffer[Idx + 2]);
}

float3 ApplyClipping(float3 Position)
{
    return Position;
}

float3 ProcessPosition(float3 Position, half3x3 TangentToLocal, int VertexID)
{
    return Position;
}

float3 ProcessPosition(float3 Position, int VertexID)
{
    return Position;
}

FPrimitiveSceneData GetPrimitiveData(FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.SceneData.Primitive;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
    return InWorldPosition;
}

void GetTangents(FVertexFactoryInput Input, out float4 Right, out float4 Up)
{
    float3 N = SafeNormalize(Input.Normal);
    float3 T = SafeNormalize(cross(N, float3(0, 0, 1)));
    float3 B = cross(N, T);
    Right = float4(T, 1);
    Up = float4(B, 1);
}

half3x3 CalcTangentToLocal()
{
    return half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

half3x3 CalcTangentToWorldNoScale(half3x3 TangentToLocal)
{
    return half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

float3x3 CalcTangentBasis(FVertexFactoryInput Input)
{
    float4 Right, Up;
    GetTangents(Input, Right, Up);
    return float3x3(Right.xyz, Up.xyz, -normalize(cross(Right.xyz, Up.xyz)));
}

float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToLocal;
    //return CalcTangentBasis(Input);
}

// ************************ Instancing, LOD, et al Support ************************
// functions expected by Unreal Engine for feature support. 

float3 VertexFactoryGetInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPreviousInstanceSpacePosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.Position;
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
    return TranslatedWorldPosition;
}

float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(
    ApplyClipping(VoxelGetInstancePosition(Input.VertexId)),
    GetPrimitiveDataFromUniformBuffer().LocalToWorld);
    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz, Input.VertexId);
    return WorldPosition;
}
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(
    ApplyClipping(VoxelGetInstancePosition(Input.VertexId)),
    GetPrimitiveDataFromUniformBuffer().LocalToWorld);
    WorldPosition.xyz = ProcessPosition(WorldPosition.xyz, Input.VertexId);
    return WorldPosition;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    float4 WorldPosition = TransformLocalToTranslatedWorld(Intermediates.Position, Intermediates.SceneData.Primitive.LocalToWorld);
    return WorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return VertexFactoryGetWorldPosition(Input, Intermediates);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return Intermediates.TangentToWorld[2];
}

float3 VertexFactoryGetWorldNormal(FPositionAndNormalOnlyVertexFactoryInput Input)
{
    return RotateLocalToWorld(Input.Normal.xyz);
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
    return 0;
}

FVertexFactoryInput LoadVertexFactoryInputFromIndices(uint TriangleIndex, int VertexIndex)
{
    FVertexFactoryInput Input = (FVertexFactoryInput) 0;
    Input.VertexId = TriangleIndex * 3 + VertexIndex;
    uint VertexOffset = floor(Input.VertexId / 4) * 5;
		
    Input.Position.x = VoxelVF.VertexFetch_Buffer[VertexOffset + 0];
    Input.Position.y = VoxelVF.VertexFetch_Buffer[VertexOffset + 1];
    Input.Position.z = VoxelVF.VertexFetch_Buffer[VertexOffset + 2];
    return Input;
}

// ************************ Parameters & Intermediates Support ************************

FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal, bool bIsPreviousFrame = false)
{
    FMaterialVertexParameters Result = MakeInitializedMaterialVertexParameters();
    Result.SceneData = Intermediates.SceneData;
    Result.WorldPosition = WorldPosition;
    Result.TangentToWorld = Intermediates.TangentToWorld;
    Result.PreSkinnedNormal = TangentToLocal[2];
    Result.PreSkinnedPosition = WorldPosition;
    Result.LWCData = MakeMaterialLWCData(Result);
    return Result;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    return MakeInitializedMaterialPixelParameters();
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS) 0;
    Interpolants.TangentToWorld0 = float4(Intermediates.TangentToWorld[0], 0);
    Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
    
    Interpolants.Color = VertexParameters.VertexColor;
    Interpolants.Alpha = Intermediates.Alpha;
    Interpolants.TexCoords = PrecomputedUV_Quad[Input.VertexId % 4 + 4];
    return Interpolants;
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
    FVertexFactoryIntermediates Intermediates;
    Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
    Intermediates.Position = Input.Position.xyz;
    Intermediates.TangentToLocal = CalcTangentToLocal();
    Intermediates.TangentToWorldSign = Intermediates.SceneData.InstanceData.DeterminantSign;
    Intermediates.TangentToWorld = CalcTangentToWorldNoScale(Intermediates.TangentToLocal);
    Intermediates.Color = Input.Color;
    Intermediates.Alpha = 1;

    return Intermediates;
}

// ************************ RayTrace & Compute Support ************************

#if RAYHITGROUPSHADER || COMPUTESHADER
uint GetNumRayTracingDynamicMeshVerticesIndirect()
{
	return 0;
}
#endif

#if COMPUTESHADER

FVertexFactoryInput LoadVertexFactoryInputForDynamicUpdate(uint TriangleIndex, int VertexIndex, uint PrimitiveId, uint DrawInstanceId)
{
	FVertexFactoryInput Input = LoadVertexFactoryInputFromIndices(TriangleIndex, VertexIndex);
		
	FPrimitiveSceneData PrimitiveData = GetPrimitiveData(PrimitiveId);
	VF_GPUSCENE_SET_INPUT_FOR_RT(Input, PrimitiveData.InstanceSceneDataOffset + DrawInstanceId, DrawInstanceId);

	return Input;
}
#endif


#include "/Engine/Private/VertexFactoryDefaultInterface.ush"
